<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SmartFlash</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the hamburger menu lines */
        .hamburger div {
            background-color: #4a5568; /* Changed to darker gray */
            height: 4px;
            border-radius: 2px;
            transition: all 0.3s ease;
        }

        /* Basic transition for menu */
        .menu {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .menu.open {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        /* Custom scrollbar for a modern look */
        body::-webkit-scrollbar {
            width: 8px;
        }
        body::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        body::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        body::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        #progressText {
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4); /* Keep text shadow for contrast */
        }
    </style>
</head>
<body class="font-sans bg-gradient-to-br from-gray-100 to-gray-200 flex flex-col items-center p-6 min-h-screen overflow-y-auto">
    <div class="card-grid grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 w-full max-w-6xl">
        <div class="flashcard bg-gradient-to-br from-purple-500 via-indigo-600 to-blue-700 text-white rounded-3xl shadow-2xl p-10 text-center cursor-pointer transition-all duration-300 ease-in-out flex items-center justify-center text-2xl font-bold tracking-wide hover:scale-[1.02] hover:shadow-3xl active:scale-[0.98]" onclick="openFlashcard(false, this.textContent.trim())">
            CS 2301 - Operating Systems 1
        </div>
    </div>

    <div class="popup fixed inset-0 bg-gradient-to-br from-gray-900/80 to-black/80 flex items-center justify-center z-50 transition-opacity duration-300 ease-in-out" id="popup" style="display: none;">
        <div class="question-box bg-white rounded-3xl w-11/12 max-w-2xl text-left relative text-gray-900 shadow-2xl border border-gray-100 backdrop-blur-sm bg-opacity-90 min-h-[250px] flex flex-col">
            
            <div class="header-area p-4 sm:p-6 pb-2 relative z-30 border-b border-gray-100">
                <div class="flex items-center justify-between mb-4">
                    <div class="hamburger w-9 h-7 flex flex-col justify-between cursor-pointer z-50" onclick="toggleMenu(event)">
                        <div></div>
                        <div></div>
                        <div></div>
                    </div>
                    <h2 id="flashcardTitleDisplay" class="text-lg sm:text-xl font-bold text-gray-800 text-center flex-grow -ml-9 truncate"></h2>
                </div>
                
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-2">
                        <span id="progressText" class="text-gray-700 text-sm font-semibold">0%</span>
                        <div id="progressBarContainer" class="flex-grow max-w-[180px] h-5 bg-gray-300 rounded-full overflow-hidden">
                            <div id="progressBar" class="h-5 rounded-full transition-all duration-300 ease-out" style="width: 0%; background-color: red;"></div>
                        </div>
                    </div>
                    
                    <div id="scoreDisplay" class="flex items-center gap-4 text-sm font-semibold text-gray-700">
                        <span class="flex items-center gap-1">Correct: <span id="correctCount" class="text-green-600 font-bold">0</span></span>
                        <span class="flex items-center gap-1">Incorrect: <span id="incorrectCount" class="text-red-600 font-bold">0</span></span>
                    </div>
                </div>
            </div>

            <div class="menu absolute top-28 left-6 bg-white rounded-xl shadow-xl overflow-hidden opacity-0 pointer-events-none transform -translate-y-4 z-40 min-w-[180px]" id="sideMenu">
                <button class="block w-full px-5 py-3 border-b border-gray-100 text-left text-base font-medium text-gray-700 cursor-pointer hover:bg-gray-50 hover:text-gray-900 transition-colors duration-200" onclick="closePopup()">Close</button>
                <button id="saveProgressBtn" class="block w-full px-5 py-3 border-b border-gray-100 text-left text-base font-medium text-gray-700 cursor-pointer hover:bg-gray-50 hover:text-gray-900 transition-colors duration-200" onclick="saveProgress(); showMessageBox('Progress saved!');">Save Progress</button>
                <button id="viewResultsBtn" class="block w-full px-5 py-3 border-b border-gray-100 text-left text-base font-medium text-gray-700 cursor-pointer hover:bg-gray-50 hover:text-gray-900 transition-colors duration-200 hidden" onclick="showEndSessionSummary()">View Results</button>
                <button class="block w-full px-5 py-3 text-left text-base font-medium text-gray-700 cursor-pointer hover:bg-gray-50 hover:text-gray-900 transition-colors duration-200" onclick="startOver()">Start Over</button>
            </div>

            <div id="questionScreen" class="flex-grow overflow-y-auto px-8 sm:px-12 py-6">
                <p id="questionText" class="mb-6 font-bold text-xl leading-relaxed">Here goes the question...</p> 
                <div id="choices" class="space-y-4"></div>
                <div id="explanation" class="mt-8 p-5 rounded-xl font-normal text-amber-800 bg-amber-50 border border-amber-200 hidden shadow-inner"></div>
            </div>

            <div class="nav-buttons flex justify-between items-center mt-0 gap-4 px-8 sm:px-12 py-6 border-t border-gray-100">
                <button class="px-8 py-3 font-bold text-lg rounded-full text-orange-800 bg-orange-200 border border-orange-300 hover:bg-orange-300 transition-all duration-200 shadow-md hover:shadow-lg active:scale-98" onclick="toggleExplanation()">Explanation</button>
                <button class="flex items-center justify-center w-12 h-12 bg-gray-700 rounded-full hover:bg-gray-800 transition-all duration-200 shadow-md hover:shadow-lg active:scale-95" onclick="prevQuestion()">
                    <svg class="w-7 h-7 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                </button>
                <button class="flex items-center justify-center w-12 h-12 bg-gray-700 rounded-full hover:bg-gray-800 transition-all duration-200 shadow-md hover:shadow-lg active:scale-95" onclick="nextQuestion()">
                    <svg class="w-7 h-7 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </button>
            </div>

            <div id="summaryScreen" class="absolute inset-0 flex flex-col items-center justify-center p-8 hidden text-center">
                <h2 class="text-4xl font-extrabold text-gray-800 mb-6 drop-shadow-md">Session Complete!</h2>
                <div class="bg-blue-50 border border-blue-200 text-blue-800 p-6 rounded-2xl shadow-lg mb-8 w-full max-w-sm">
                    <p class="text-xl font-semibold mb-2">Total Questions: <span id="totalQuestionsSummary" class="text-blue-700">0</span></p>
                    <p class="text-xl font-semibold mb-2">Correct Answers: <span id="correctAnswersSummary" class="text-green-600 font-bold">0</span></p>
                    <p class="text-xl font-semibold">Incorrect Answers: <span id="incorrectAnswersSummary" class="text-red-600 font-bold">0</span></p>
                </div>

                <div class="flex flex-col space-y-4 w-full max-w-xs">
                    <button id="reviewAnswersBtn" class="px-8 py-3 font-bold text-lg rounded-full text-purple-800 bg-purple-200 border border-purple-300 hover:bg-purple-300 transition-all duration-200 shadow-md hover:shadow-lg active:scale-98" onclick="startReviewMode()">Review Answers</button>
                    <button class="px-8 py-3 font-bold text-lg rounded-full text-blue-800 bg-blue-200 border border-blue-300 hover:bg-blue-300 transition-all duration-200 shadow-md hover:shadow-lg active:scale-98" onclick="openFlashcard(true)">Start New Session</button> 
                    <button class="px-8 py-3 font-bold text-lg rounded-full text-gray-700 bg-gray-200 border border-gray-300 hover:bg-gray-300 transition-all duration-200 shadow-md hover:shadow-lg active:scale-98" onclick="closePopup()">Go Back to Main Menu</button>
                </div>
            </div>

        </div>
    </div>

    <div id="messageBox" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-sm w-full border border-gray-100">
            <p id="messageText" class="text-xl font-semibold mb-6 text-gray-800"></p>
            <button class="bg-blue-600 text-white px-6 py-3 rounded-xl hover:bg-blue-700 transition-colors duration-200 shadow-md active:scale-98" onclick="hideMessageBox()">OK</button>
        </div>
    </div>

    <script>
        // questions array will now be populated from JSON
        let questions = []; 
        let currentQuestionIndex = 0; 
        let answered = false; // Flag to check if the current question has been answered
        let shuffledQuestions = []; 
        let reviewMode = false; // Flag to indicate if currently in review mode
        
        // Score tracking variables
        let correctAnswersCount = 0;
        let incorrectAnswersCount = 0;

        // Constants for Local Storage keys
        const LOCAL_STORAGE_KEY_QUESTIONS = 'smartflash_shuffled_questions';
        const LOCAL_STORAGE_KEY_CURRENT_INDEX = 'smartflash_current_index';
        const LOCAL_STORAGE_KEY_CORRECT_COUNT = 'smartflash_correct_count';
        const LOCAL_STORAGE_KEY_INCORRECT_COUNT = 'smartflash_incorrect_count';

        // Get DOM elements
        const popup = document.getElementById('popup');
        const questionScreen = document.getElementById('questionScreen'); 
        const summaryScreen = document.getElementById('summaryScreen'); 
        const questionText = document.getElementById('questionText');
        const choicesDiv = document.getElementById('choices');
        const explanationDiv = document.getElementById('explanation');
        const sideMenu = document.getElementById('sideMenu');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const flashcardTitleDisplay = document.getElementById('flashcardTitleDisplay'); 
        
        // Progress bar elements
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');

        // Score display elements
        const correctCountSpan = document.getElementById('correctCount');
        const incorrectCountSpan = document.getElementById('incorrectCount');

        // Summary screen elements
        const viewResultsBtn = document.getElementById('viewResultsBtn');
        const saveProgressBtn = document.getElementById('saveProgressBtn'); 
        const totalQuestionsSummary = document.getElementById('totalQuestionsSummary');
        const correctAnswersSummary = document.getElementById('correctAnswersSummary');
        const incorrectAnswersSummary = document.getElementById('incorrectAnswersSummary');
        const reviewAnswersBtn = document.getElementById('reviewAnswersBtn');


        /**
         * Shuffles an array in place using the Fisher-Yates (Knuth) algorithm.
         * For persistent answer display, we also initialize answer tracking properties.
         * @param {Array} array - The array to shuffle.
         */
        function shuffleArray(array) {
            // Create a deep copy to ensure original questions array is not modified
            const newArray = JSON.parse(JSON.stringify(array)); 
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]]; // Swap elements
            }
            // Initialize answer tracking properties for each question in the shuffled array
            newArray.forEach(q => {
                q.userAnsweredIndex = -1; // -1 means not answered
                q.isCorrectlyAnswered = null; // null means not answered, true/false after answering
                q.explanationShown = false; // Track if explanation was shown for this question
            });
            return newArray;
        }

        /**
         * Loads questions from a JSON file.
         */
        async function loadQuestionsFromJson() {
            try {
                const response = await fetch('questions.json'); // Path to your JSON file
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                questions = await response.json();
                console.log('Questions loaded from JSON:', questions);
            }
            catch (error) {
                console.error('Could not load questions from JSON:', error);
                showMessageBox('Failed to load questions. Please check the questions.json file.');
            }
        }

        // Call loadQuestionsFromJson when the script starts (page loads)
        loadQuestionsFromJson();


        /**
         * Displays a custom message box.
         * @param {string} message - The message to display.
         */
        function showMessageBox(message) {
            messageText.textContent = message;
            messageBox.classList.remove('hidden');
            console.log('Message box shown:', message); // Debugging log
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            messageBox.classList.add('hidden');
            console.log('Message box hidden.'); // Debugging log
        }

        /**
         * Determines the color of the progress bar based on percentage.
         * @param {number} percentage - The current progress percentage (0-100).
         * @returns {string} - The hex color string.
         */
        function getProgressBarColor(percentage) {
            if (percentage <= 25) {
                return '#ef4444'; // Tailwind red-500
            } else if (percentage <= 50) {
                return '#f97316'; // Tailwind orange-500
            } else if (percentage <= 75) {
                return '#eab308'; // Tailwind yellow-500
            } else {
                return '#22c55e'; // Tailwind green-500
            }
        }

        /**
         * Checks if all questions have been answered.
         * @returns {boolean} True if all questions are answered, false otherwise.
         */
        function allQuestionsAnswered() {
            return shuffledQuestions.length > 0 && shuffledQuestions.every(q => q.userAnsweredIndex !== -1);
        }

        /**
         * Updates the progress bar and percentage text based on answered questions.
         */
        function updateProgressBar() {
            if (shuffledQuestions.length === 0) {
                progressBar.style.width = '0%';
                progressText.textContent = '0%';
                progressBar.style.backgroundColor = getProgressBarColor(0); // Set initial color
                return;
            }

            const answeredQuestionsCount = shuffledQuestions.filter(q => q.userAnsweredIndex !== -1).length;
            const totalQuestions = shuffledQuestions.length;
            const progress = (answeredQuestionsCount / totalQuestions) * 100;

            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${Math.round(progress)}%`;
            progressBar.style.backgroundColor = getProgressBarColor(progress); // Set dynamic color
            console.log(`Progress: ${Math.round(progress)}% (Answered: ${answeredQuestionsCount}/${totalQuestions})`); // Debugging log
        }

        /**
         * Updates the display of correct and incorrect answer counts.
         */
        function updateScoreDisplay() {
            correctCountSpan.textContent = correctAnswersCount;
            incorrectCountSpan.textContent = incorrectAnswersCount;
            console.log(`Score Display Updated: Correct=${correctAnswersCount}, Incorrect=${incorrectAnswersCount}`);
        }

        /**
         * Saves the current session progress to Local Storage.
         */
        function saveProgress() {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY_QUESTIONS, JSON.stringify(shuffledQuestions));
                localStorage.setItem(LOCAL_STORAGE_KEY_CURRENT_INDEX, currentQuestionIndex.toString());
                localStorage.setItem(LOCAL_STORAGE_KEY_CORRECT_COUNT, correctAnswersCount.toString());
                localStorage.setItem(LOCAL_STORAGE_KEY_INCORRECT_COUNT, incorrectAnswersCount.toString());
                console.log('Progress saved successfully.');
            } catch (e) {
                console.error('Error saving progress to Local Storage:', e);
                showMessageBox('Failed to save progress. Storage limit might be reached.');
            }
        }

        /**
         * Loads session progress from Local Storage.
         * @returns {boolean} True if progress was loaded, false otherwise.
         */
        function loadProgress() {
            try {
                const savedQuestions = localStorage.getItem(LOCAL_STORAGE_KEY_QUESTIONS);
                const savedIndex = localStorage.getItem(LOCAL_STORAGE_KEY_CURRENT_INDEX);
                const savedCorrect = localStorage.getItem(LOCAL_STORAGE_KEY_CORRECT_COUNT);
                const savedIncorrect = localStorage.getItem(LOCAL_STORAGE_KEY_INCORRECT_COUNT);

                if (savedQuestions && savedIndex !== null && savedCorrect !== null && savedIncorrect !== null) {
                    shuffledQuestions = JSON.parse(savedQuestions);
                    currentQuestionIndex = parseInt(savedIndex, 10);
                    correctAnswersCount = parseInt(savedCorrect, 10);
                    incorrectAnswersCount = parseInt(savedIncorrect, 10);
                    console.log('Progress loaded successfully.');
                    return true;
                }
                console.log('No saved progress found.');
                return false;
            } catch (e) {
                console.error('Error loading progress from Local Storage:', e);
                clearSavedProgress(); 
                showMessageBox('Failed to load saved progress. Starting new session.');
                return false;
            }
        }

        /**
         * Clears all saved progress from Local Storage.
         */
        function clearSavedProgress() {
            localStorage.removeItem(LOCAL_STORAGE_KEY_QUESTIONS);
            localStorage.removeItem(LOCAL_STORAGE_KEY_CURRENT_INDEX);
            localStorage.removeItem(LOCAL_STORAGE_KEY_CORRECT_COUNT);
            localStorage.removeItem(LOCAL_STORAGE_KEY_INCORRECT_COUNT);
            console.log('Saved progress cleared.');
        }

        /**
         * Opens the flashcard popup and loads the first question.
         * Resets state for a new session OR loads saved progress.
         * @param {boolean} [forceNewSession=false] - If true, always start a new session, ignoring saved progress.
         * @param {string} [flashcardName='Flashcards'] - The name of the flashcard set being opened.
         */
        function openFlashcard(forceNewSession = false, flashcardName = 'Flashcards') {
            console.log('openFlashcard called. forceNewSession:', forceNewSession, 'Flashcard Name:', flashcardName);
            if (questions.length === 0) {
                showMessageBox('No questions loaded yet. Please wait or check the JSON file.');
                return;
            }

            document.body.style.overflow = 'hidden'; // Prevent body scrolling and pull-to-refresh
            popup.style.display = 'flex';
            reviewMode = false; // Ensure not in review mode
            
            // Set the flashcard title based on the argument
            flashcardTitleDisplay.textContent = flashcardName; 

            let progressLoaded = false;
            if (!forceNewSession) {
                progressLoaded = loadProgress();
            }

            if (!progressLoaded) {
                shuffledQuestions = shuffleArray([...questions]); // Shuffle and initialize tracking properties
                currentQuestionIndex = 0;
                correctAnswersCount = 0;
                incorrectAnswersCount = 0;
                console.log('New session started. Scores reset: Correct = 0, Incorrect = 0');
                clearSavedProgress(); // Clear old progress if starting a new one
            } else {
                console.log('Resuming session from saved progress.');
            }
            
            // Hide summary screen, show question screen
            summaryScreen.classList.add('hidden');
            questionScreen.classList.remove('hidden');
            viewResultsBtn.classList.add('hidden'); // Hide results button initially (will be shown by toggleMenu if all answered)
            sideMenu.classList.remove('open'); // Ensure menu is closed when opening popup

            updateScoreDisplay(); 
            loadQuestion(currentQuestionIndex);
        }

        /**
         * Loads and displays a question based on its index.
         * @param {number} index - The index of the question to load.
         */
        function loadQuestion(index) {
            console.log('loadQuestion called with index:', index);
            if (index < 0 || index >= shuffledQuestions.length) {
                console.error('Invalid question index:', index);
                return;
            }

            const q = shuffledQuestions[index];
            
            questionText.textContent = `${index + 1}. ${q.question}`;
            console.log('Question text updated:', questionText.textContent);

            explanationDiv.classList.add('hidden'); // Ensure explanation is hidden by default
            explanationDiv.textContent = ''; // Clear previous explanation content
            
            // Set 'answered' flag based on whether this question was previously answered
            answered = (q.userAnsweredIndex !== -1); 
            choicesDiv.innerHTML = ''; // Clear previous choices

            q.choices.forEach((choice, i) => {
                const container = document.createElement('div');
                container.className = 'choice-container flex items-center mb-4 p-3 rounded-lg hover:bg-gray-50 transition-colors duration-200 cursor-pointer';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = 'choice';
                checkbox.id = 'choice' + i;
                // Disable checkbox if question is answered OR if in review mode
                checkbox.disabled = answered || reviewMode; 
                checkbox.className = 'mr-4 transform scale-150 cursor-pointer accent-blue-600 focus:ring-2 focus:ring-blue-500';

                const label = document.createElement('label');
                label.htmlFor = 'choice' + i;
                label.textContent = `${String.fromCharCode(97 + i)}. ${choice}`;
                label.className = 'text-lg cursor-pointer flex-grow text-gray-700';

                const iconCorrect = document.createElement('span');
                iconCorrect.className = 'icon correct ml-4 text-2xl hidden'; 
                iconCorrect.textContent = '✔';

                const iconWrong = document.createElement('span');
                iconWrong.className = 'icon wrong ml-4 text-2xl font-bold hidden'; 
                iconWrong.textContent = 'X';

                // Re-apply visual state if question was previously answered OR if in review mode
                if (answered || reviewMode) {
                    checkbox.checked = (i === q.userAnsweredIndex); // Check the user's previous answer
                    
                    // Apply styling for user's selected answer
                    if (i === q.userAnsweredIndex) { 
                        if (q.isCorrectlyAnswered) {
                            container.classList.add('bg-green-100', 'border-green-300');
                            iconCorrect.classList.remove('hidden');
                            iconCorrect.style.setProperty('color', 'green', 'important');
                        } else {
                            container.classList.add('bg-red-100', 'border-red-300');
                            iconWrong.classList.remove('hidden');
                            iconWrong.style.setProperty('color', 'red', 'important');
                        }
                    }

                    // Only show the correct answer's highlight if in review mode OR if explanation was shown for an incorrect answer
                    if (i === q.correctIndex && (reviewMode || (answered && !q.isCorrectlyAnswered && q.explanationShown))) {
                        container.classList.add('bg-green-100', 'border-green-300');
                        iconCorrect.classList.remove('hidden');
                        iconCorrect.style.setProperty('color', 'green', 'important');
                    }
                }

                checkbox.addEventListener('change', () => {
                    if (answered || reviewMode) return; // Prevent re-answering or answering in review mode
                    
                    answered = true; 
                    q.userAnsweredIndex = i; 
                    q.isCorrectlyAnswered = (i === q.correctIndex);

                    console.log('Choice selected:', i, 'Answered:', answered);

                    document.querySelectorAll('.choice-container input[type="checkbox"]').forEach(cb => cb.disabled = true);

                    if (q.isCorrectlyAnswered) {
                        container.classList.add('bg-green-100', 'border-green-300');
                        iconCorrect.classList.remove('hidden');
                        iconCorrect.style.setProperty('color', 'green', 'important'); 
                        correctAnswersCount++;
                        console.log(`Correct answer! Current score: Correct=${correctAnswersCount}, Incorrect=${incorrectAnswersCount}`);
                    } else {
                        container.classList.add('bg-red-100', 'border-red-300');
                        iconWrong.classList.remove('hidden');
                        iconWrong.style.setProperty('color', 'red', 'important');
                        incorrectAnswersCount++;
                        console.log(`Incorrect answer! Current score: Correct=${incorrectAnswersCount}, Incorrect=${incorrectAnswersCount}`);
                    }
                    updateScoreDisplay(); 
                    updateProgressBar(); 
                    saveProgress(); 
                    
                    // Automatic Summary Generation
                    if (allQuestionsAnswered()) {
                        console.log("All questions answered. Showing summary.");
                        showEndSessionSummary();
                    }
                });

                container.appendChild(checkbox);
                container.appendChild(label);
                container.appendChild(iconCorrect);
                container.appendChild(iconWrong);
                choicesDiv.appendChild(container);
            });

            // Re-apply explanation if previously shown OR if in review mode
            if (q.explanationShown || reviewMode) {
                explanationDiv.textContent = q.explanation;
                explanationDiv.classList.remove('hidden');
            }

            updateProgressBar();
        }

        /**
         * Navigates to the previous question.
         */
        function prevQuestion() {
            console.log('prevQuestion called.');
            if (!answered && !reviewMode) { 
                showMessageBox('Please select an answer for the current question before moving back.');
                return; 
            }
            currentQuestionIndex = (currentQuestionIndex - 1 + shuffledQuestions.length) % shuffledQuestions.length;
            loadQuestion(currentQuestionIndex);
        }

        /**
         * Navigates to the next question.
         */
        function nextQuestion() {
            console.log('nextQuestion called.');
            if (!answered && !reviewMode) { 
                showMessageBox('Please select an answer for the current question before moving forward.');
                return; 
            }
            // If all questions are answered and we're navigating next, show summary (fallback if auto missed)
            if (allQuestionsAnswered() && currentQuestionIndex === shuffledQuestions.length -1 && !reviewMode) {
                 showEndSessionSummary();
                 return;
            }

            currentQuestionIndex = (currentQuestionIndex + 1) % shuffledQuestions.length;
            loadQuestion(currentQuestionIndex);
        }

        /**
         * Toggles the visibility of the explanation for the current question.
         */
        function toggleExplanation() {
            console.log('toggleExplanation called. Answered:', answered, 'Review Mode:', reviewMode);
            if (!answered && !reviewMode) { 
                showMessageBox('Please select an answer first.');
                return;
            }
            const q = shuffledQuestions[currentQuestionIndex];
            console.log('Explanation content for current question:', q.explanation);
            explanationDiv.textContent = q.explanation;
            explanationDiv.classList.toggle('hidden');
            q.explanationShown = !explanationDiv.classList.contains('hidden'); 

            // Reveal correct answer if the user's answer was wrong or if in review mode
            if ((q.userAnsweredIndex !== -1 && !q.isCorrectlyAnswered) || reviewMode) {
                const correctContainer = document.getElementById('choice' + q.correctIndex).parentNode;
                const correctIcon = correctContainer.querySelector('.icon.correct');

                correctContainer.classList.add('bg-green-100', 'border-green-300');
                correctIcon.classList.remove('hidden');
                correctIcon.style.setProperty('color', 'green', 'important');
            }
        }

        /**
         * Toggles the visibility of the side menu.
         * @param {Event} event - The click event to stop propagation.
         */
        function toggleMenu(event) {
            event.stopPropagation(); // Prevent the document click listener from immediately closing the menu
            console.log('toggleMenu called.');
            sideMenu.classList.toggle('open');

            // Show/Hide View Results button based on completion
            if (allQuestionsAnswered()) {
                viewResultsBtn.classList.remove('hidden');
            } else {
                viewResultsBtn.classList.add('hidden');
            }
        }

        /**
         * Implements the "Start Over" functionality.
         */
        function startOver() {
            console.log('Start Over clicked.');
            clearSavedProgress(); 
            closePopup(); 
            openFlashcard(true, flashcardTitleDisplay.textContent); 
            showMessageBox('Flashcard session restarted!');
        }

        /**
         * Closes the flashcard popup and the side menu.
         * Also saves progress on close.
         */
        function closePopup() {
            console.log('closePopup called.');
            // Save progress before closing, in case it wasn't saved by an answer
            if (!allQuestionsAnswered()) { 
                 saveProgress();
            }
            popup.style.display = 'none';
            sideMenu.classList.remove('open');
            // Ensure summary is hidden if we close the popup
            summaryScreen.classList.add('hidden');
            questionScreen.classList.remove('hidden'); 
            document.body.style.overflow = ''; // Restore body scrolling
        }

        /**
         * Displays the end-of-session summary screen.
         */
        function showEndSessionSummary() {
            console.log("Showing end session summary.");
            questionScreen.classList.add('hidden'); 
            summaryScreen.classList.remove('hidden'); 

            // Populate summary details
            totalQuestionsSummary.textContent = shuffledQuestions.length;
            correctAnswersSummary.textContent = correctAnswersCount;
            incorrectAnswersSummary.textContent = incorrectAnswersCount;
            
            // Ensure View Results button is visible in menu if user is on summary screen
            viewResultsBtn.classList.remove('hidden'); 
            sideMenu.classList.remove('open'); 

            clearSavedProgress(); 
        }

        /**
         * Placeholder function for starting review mode.
         */
        function startReviewMode() {
            console.log("Entering review mode.");
            reviewMode = true;
            summaryScreen.classList.add('hidden');
            questionScreen.classList.remove('hidden');
            currentQuestionIndex = 0; // Start review from the first question
            loadQuestion(currentQuestionIndex);
            showMessageBox("Reviewing answers. You cannot change selections in review mode.");
        }

        // Add a global click listener to close the menu when clicking outside
        document.addEventListener('click', function(event) {
            const isClickInsideMenu = sideMenu.contains(event.target);
            const isClickOnHamburger = event.target.closest('.hamburger'); // Check if click was on hamburger itself

            if (!isClickInsideMenu && !isClickOnHamburger && sideMenu.classList.contains('open')) {
                sideMenu.classList.remove('open');
            }
        });
    </script>
</body>
</html>
