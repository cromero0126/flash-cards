[
  {
    "question": "Which phase of the SDLC involves gathering and analyzing project requirements?",
    "choices": [
      "Requirements analysis",
      "Testing",
      "Design",
      "Implementation"
    ],
    "correctIndex": 0,
    "explanation": "The Requirements Analysis phase is crucial for defining what the software system needs to do. During this stage, stakeholders' needs are collected, documented, and thoroughly understood to form the foundation for all subsequent development activities."
  },
  {
    "question": "Coupling refers to the level of dependency between software modules.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. Coupling measures how much one software module relies on another. High coupling indicates strong dependencies, which can make systems harder to understand, modify, and test, while low coupling is generally desired for robust and maintainable software."
  },
  {
    "question": "Which SDLC model emphasizes customer collaboration over contract negotiation?",
    "choices": [
      "Agile",
      "Waterfall",
      "Spiral",
      "Incremental"
    ],
    "correctIndex": 0,
    "explanation": "The Agile SDLC model prioritizes continuous customer collaboration throughout the development process. This emphasis ensures that the software evolves to meet changing needs and deliver maximum value, contrasting with more rigid, contract-focused approaches."
  },
  {
    "question": "The process of dividing a software project into smaller, manageable tasks is known as _____.",
    "choices": [
      "Decomposition",
      "Refactoring",
      "Debugging",
      "Optimization"
    ],
    "correctIndex": 0,
    "explanation": "Decomposition involves breaking down a complex problem or project into smaller, more manageable components or tasks. This practice simplifies development, allows for parallel work, and makes it easier to track progress and identify potential issues within each smaller piece."
  },
  {
    "question": "Which role focuses on writing and maintaining the source code?",
    "choices": [
      "Software Developer",
      "Project Manager",
      "System Analyst",
      "UX Designer"
    ],
    "correctIndex": 0,
    "explanation": "A Software Developer is primarily responsible for translating design specifications into executable code. Their duties involve writing, debugging, and maintaining the software's source code, ensuring it functions as intended and meets project requirements."
  },
  {
    "question": "In which SDLC model are prototypes created for client feedback?",
    "choices": [
      "Prototyping",
      "Waterfall",
      "Agile",
      "Spiral"
    ],
    "correctIndex": 0,
    "explanation": "The Prototyping model explicitly involves creating preliminary versions of the software (prototypes) to gather early and iterative feedback from clients. This helps refine requirements and design before full-scale development, reducing the risk of building the wrong product."
  },
  {
    "question": "What is the role of the Project Manager?",
    "choices": [
      "Overseeing the project schedule, budget, and team coordination",
      "Writing technical code",
      "Testing software functionality",
      "Designing system architecture"
    ],
    "correctIndex": 0,
    "explanation": "The Project Manager is central to leading and guiding the software development team. Their responsibilities include defining project goals, creating detailed plans, managing resources and budgets, and ensuring effective communication and coordination among all team members to achieve successful delivery."
  },
  {
    "question": "_____ is the phase of SDLC where the system is thoroughly tested for errors and bugs.",
    "choices": [
      "Testing",
      "Development",
      "Design",
      "Implementation"
    ],
    "correctIndex": 0,
    "explanation": "The Testing phase is a critical stage in the SDLC dedicated to identifying defects, errors, and omissions in the software. Various testing techniques are employed to ensure the system meets specified requirements, performs reliably, and delivers a high-quality user experience."
  },
  {
    "question": "Which SDLC model incorporates risk assessment as a key component?",
    "choices": [
      "Spiral",
      "Waterfall",
      "Agile",
      "Incremental"
    ],
    "correctIndex": 0,
    "explanation": "The Spiral model is renowned for its emphasis on risk management, integrating risk assessment activities into each iteration. This iterative approach allows for systematic identification, analysis, and mitigation of risks throughout the project lifecycle, making it suitable for large and complex endeavors."
  },
  {
    "question": "The primary goal of the SDLC is to ensure structured and efficient software development.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. The Software Development Life Cycle (SDLC) provides a structured framework for managing the entire software development process, from conception to maintenance. Its goal is to deliver high-quality software systematically, within budget, and on schedule, by clearly defining phases and responsibilities."
  },
  {
    "question": "What is Software Engineering?",
    "choices": [
      "Applying systematic engineering principles to software development",
      "Writing code for software",
      "Testing software for errors",
      "Building hardware components"
    ],
    "correctIndex": 0,
    "explanation": "Software Engineering is a systematic, disciplined, and quantifiable approach to the development, operation, and maintenance of software. It applies engineering principles to create high-quality software solutions that are reliable, efficient, and meet user requirements."
  },
  {
    "question": "Who ensures that software quality standards are met through rigorous testing?",
    "choices": [
      "Quality Assurance Tester",
      "Software Developer",
      "System Administrator",
      "Business Analyst"
    ],
    "correctIndex": 0,
    "explanation": "A Quality Assurance (QA) Tester is responsible for systematically verifying that the software meets quality standards and functional requirements. They design and execute test cases, identify defects, and work with the development team to ensure a robust and reliable product before release."
  },
  {
    "question": "Which role focuses on creating visual and interactive elements of a system?",
    "choices": [
      "UX Designer",
      "Software Developer",
      "QA Tester",
      "System Administrator"
    ],
    "correctIndex": 0,
    "explanation": "A UX (User Experience) Designer focuses on enhancing user satisfaction by improving the usability, accessibility, and pleasure provided in the interaction between the user and the product. This involves researching user behaviors, designing intuitive interfaces, and creating engaging experiences."
  },
  {
    "question": "The primary drawback of the Waterfall model is:",
    "choices": [
      "Inability to accommodate changes mid-project",
      "Lack of documentation",
      "High risk of project failure",
      "Low-quality deliverables"
    ],
    "correctIndex": 0,
    "explanation": "The Waterfall model's strict sequential nature makes it highly inflexible to changes once a phase is completed. This rigidity means that accommodating new requirements or correcting early-stage errors late in the project can be costly and disruptive, making it less suitable for dynamic environments."
  },
  {
    "question": "In the Waterfall model, testing occurs only at the end of the development cycle.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. A defining characteristic of the traditional Waterfall model is that testing is a distinct phase that begins only after all development and implementation are complete. This sequential approach means defects found late can be expensive and time-consuming to fix."
  },
  {
    "question": "Which SDLC model is known for its strict sequential approach?",
    "choices": [
      "Waterfall",
      "Agile",
      "Spiral",
      "Iterative"
    ],
    "correctIndex": 0,
    "explanation": "The Waterfall model is characterized by its linear and sequential approach, where each phase must be completed before the next one begins. This strict progression makes it easy to manage but less adaptable to changes that may arise during the project."
  },
  {
    "question": "Who is responsible for translating client requirements into technical specifications?",
    "choices": [
      "Business Analyst",
      "Software Developer",
      "Project Manager",
      "QA Tester"
    ],
    "correctIndex": 0,
    "explanation": "A Business Analyst (BA) serves as a crucial liaison, bridging the gap between business stakeholders and the technical development team. They elicit, analyze, document, and translate high-level client requirements into detailed technical specifications that developers can implement."
  },
  {
    "question": "What is \"Abstraction\" in Software Engineering?",
    "choices": [
      "Ignoring implementation details to focus on functionality",
      "Writing complex code for every task",
      "Avoiding software reuse",
      "Removing features from software"
    ],
    "correctIndex": 0,
    "explanation": "Abstraction in software engineering involves simplifying complex systems by focusing on essential features and hiding unnecessary details. This allows developers to manage complexity, design modular components, and improve the overall readability and maintainability of the code by representing only the relevant information."
  },
  {
    "question": "The term \"Maintainability\" in Software Engineering refers to:",
    "choices": [
      "The ease of modifying software to meet new requirements",
      "The ability to run on multiple platforms",
      "The time it takes to complete a project",
      "The aesthetics of the user interface"
    ],
    "correctIndex": 0,
    "explanation": "Maintainability is a critical quality attribute of software, indicating how easily the software can be modified, adapted, or repaired after deployment. Highly maintainable software is easier to debug, enhance, and evolve over its lifecycle, leading to lower long-term costs."
  },
  {
    "question": "A DevOps Engineer is primarily responsible for:",
    "choices": [
      "Managing software releases and automation",
      "Designing user interfaces",
      "Writing technical documentation",
      "Creating test cases"
    ],
    "correctIndex": 0,
    "explanation": "A DevOps Engineer plays a key role in bridging the gap between development and operations teams. They focus on automating the software delivery pipeline, managing infrastructure, and ensuring seamless integration and continuous deployment, thereby streamlining software releases and improving operational efficiency."
  },
  {
    "question": "What is the primary responsibility of a Software Architect?",
    "choices": [
      "Designing the high-level structure of the software system",
      "Writing and debugging code",
      "Creating marketing materials",
      "Testing for software bugs"
    ],
    "correctIndex": 0,
    "explanation": "A Software Architect defines the overall structure of a software system, including its components, their relationships, and the principles and guidelines governing its design and evolution. They make critical decisions about technology choices and architectural patterns to ensure scalability, reliability, and maintainability."
  },
  {
    "question": "What does a Scrum Master facilitate in Agile projects?",
    "choices": [
      "Team communication and adherence to Agile practices",
      "Client relations",
      "Designing user interfaces",
      "Debugging code"
    ],
    "correctIndex": 0,
    "explanation": "A Scrum Master acts as a facilitator for the Scrum team, ensuring adherence to Agile principles and practices. They remove impediments, coach the team in self-organization and cross-functionality, and foster a collaborative environment to maximize productivity and deliver value."
  },
  {
    "question": "Who is primarily responsible for system deployment and ensuring its availability?",
    "choices": [
      "System Administrator",
      "Database Administrator",
      "Quality Assurance Tester",
      "Business Analyst"
    ],
    "correctIndex": 0,
    "explanation": "The System Administrator is crucial for deploying, configuring, and maintaining the operational infrastructure of software systems. Their role ensures that systems are available, perform optimally, and are securely managed, often involving tasks like server maintenance, network configuration, and user access control."
  },
  {
    "question": "\"Reusability\" in software reduces:",
    "choices": [
      "Development time and cost",
      "Scalability of the project",
      "Testing requirements",
      "Dependency among modules"
    ],
    "correctIndex": 0,
    "explanation": "Software reusability allows developers to use existing components or modules in new applications, significantly reducing development time and costs. By leveraging previously built and tested code, it also enhances reliability and speeds up the delivery of new software features."
  },
  {
    "question": "The Agile model is best suited for:",
    "choices": [
      "Dynamic and evolving requirements",
      "Projects with clearly defined requirements from the start",
      "Small-scale projects only",
      "Projects requiring minimal client interaction"
    ],
    "correctIndex": 0,
    "explanation": "The Agile model thrives in environments where requirements are expected to change frequently or are not fully defined at the outset. Its iterative and flexible nature allows teams to adapt to evolving needs, incorporating feedback continuously and delivering value in small, incremental releases."
  },
  {
    "question": "Who handles version control and code integration?",
    "choices": [
      "Configuration Manager",
      "Quality Assurance Tester",
      "System Analyst",
      "Software Developer"
    ],
    "correctIndex": 0,
    "explanation": "A Configuration Manager is responsible for managing changes to software configurations, including source code, documentation, and other project assets. They ensure proper version control, facilitate code integration, and maintain the integrity and traceability of the software throughout its lifecycle."
  },
  {
    "question": "One of the main characteristics of software is its _____, which allows changes to be made post-deployment.",
    "choices": [
      "Maintainability",
      "Scalability",
      "Portability",
      "Robustness"
    ],
    "correctIndex": 0,
    "explanation": "Maintainability refers to the ease with which software can be modified to correct errors, improve performance, or adapt to changes in the environment or requirements after it has been deployed. This characteristic is crucial for the long-term viability and evolution of any software system."
  },
  {
    "question": "The Incremental model delivers:",
    "choices": [
      "Software in small, workable increments",
      "Fully functional software in a single phase",
      "Software after comprehensive testing",
      "High-risk projects with detailed risk assessments"
    ],
    "correctIndex": 0,
    "explanation": "The Incremental model breaks down the software development process into a series of smaller, sequential iterations. Each increment builds upon the previous one, delivering a functional subset of the overall system to the client in stages, allowing for early feedback and gradual feature rollout."
  },
  {
    "question": "Who acts as the bridge between the development team and clients?",
    "choices": [
      "Business Analyst",
      "UX Designer",
      "System Analyst",
      "Software Developer"
    ],
    "correctIndex": 0,
    "explanation": "A Business Analyst (BA) acts as the crucial liaison, translating stakeholder needs and business requirements into clear, actionable specifications for the development team. They ensure that the technical solution aligns with business goals and client expectations, facilitating smooth communication and understanding."
  },
  {
    "question": "What does software quality refer to?",
    "choices": [
      "Meeting customer expectations and functional requirements",
      "The amount of code written",
      "High salaries of developers",
      "Using the latest technologies"
    ],
    "correctIndex": 0,
    "explanation": "Software quality is multifaceted, primarily referring to how well a software product meets its specified functional and non-functional requirements, and satisfies the explicit and implicit needs of its users. It encompasses aspects like reliability, usability, efficiency, and maintainability."
  },
  {
    "question": "Which is NOT a characteristic of good software?",
    "choices": [
      "High cost",
      "Usability",
      "Scalability",
      "Reliability"
    ],
    "correctIndex": 0,
    "explanation": "While software development involves costs, 'high cost' itself is not a characteristic of *good* software. Instead, good software is characterized by attributes like usability, scalability, and reliability, which contribute to its value and effectiveness in meeting user needs and performing its intended functions efficiently."
  },
  {
    "question": "_____ is the process for capturing the functionality and requirements of a software system.",
    "choices": [
      "Requirements analysis",
      "Coding",
      "Testing",
      "Deployment"
    ],
    "correctIndex": 0,
    "explanation": "Requirements analysis is the foundational phase where the specific functionalities, constraints, and user expectations for a software system are systematically gathered, documented, and refined. This meticulous process ensures that the development team has a clear understanding of 'what' needs to be built."
  },
  {
    "question": "Which layer in software development focuses on user interaction?",
    "choices": [
      "Presentation layer",
      "Application logic layer",
      "Database layer",
      "Integration layer"
    ],
    "correctIndex": 0,
    "explanation": "The presentation layer, also known as the user interface (UI) layer, is responsible for how the system interacts with users. It handles the visual display of information and captures user input, serving as the primary point of interaction within a multi-tiered software architecture."
  },
  {
    "question": "Which requirement category includes features like user authentication and report generation?",
    "choices": [
      "Functional requirements",
      "Non-functional requirements",
      "Operational requirements",
      "Security requirements"
    ],
    "correctIndex": 0,
    "explanation": "Functional requirements define what the system *does* to fulfill user needs, encompassing specific features and behaviors. User authentication and report generation are clear examples of such features, outlining the distinct actions the software must perform."
  },
  {
    "question": "Surveys are less structured than interviews for gathering requirements.",
    "choices": [
      "False",
      "True"
    ],
    "correctIndex": 0,
    "explanation": "False. Surveys are generally more structured than interviews, using predefined questions to gather consistent data from a larger audience. Interviews, by contrast, offer more flexibility for probing deeper and exploring nuanced perspectives through open-ended conversations."
  },
  {
    "question": "What does a use case diagram primarily depict?",
    "choices": [
      "Interactions between users and the system",
      "Data flow in the system",
      "System hardware architecture",
      "Non-functional requirements"
    ],
    "correctIndex": 0,
    "explanation": "A use case diagram provides a high-level view of how different users, or 'actors', interact with a system to achieve specific goals. It illustrates the primary functions the system performs from the perspective of its external users, without delving into internal implementation details."
  },
  {
    "question": "Verification ensures that the requirements are correct and complete.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. Verification is the process of confirming that the requirements are well-formed, consistent, and adhere to defined standards. It ensures that 'we are building the product right' by checking the quality of the requirements themselves before development proceeds."
  },
  {
    "question": "____________ helps prioritize requirements by analyzing their impact and feasibility.",
    "choices": [
      "Feasibility studies",
      "Prototyping",
      "Requirement workshops",
      "Document analysis"
    ],
    "correctIndex": 0,
    "explanation": "Feasibility studies are conducted early in a project to assess the practicality and viability of proposed requirements. They analyze technical, economic, legal, operational, and schedule aspects to determine if a requirement can realistically be implemented, thus aiding in prioritization based on impact and feasibility."
  },
  {
    "question": "What is the primary goal of requirements validation?",
    "choices": [
      "Confirm requirements meet user needs",
      "Ensure system requirements are testable",
      "Align requirements with software design",
      "Prioritize high-risk requirements"
    ],
    "correctIndex": 0,
    "explanation": "Requirements validation focuses on ensuring that the gathered and documented requirements accurately reflect the real needs and expectations of the stakeholders and end-users. Its goal is to confirm that 'we are building the *right* product' that will solve the intended problem or fulfill the business objective."
  },
  {
    "question": "Which activity is NOT part of validation?",
    "choices": [
      "Debugging code errors",
      "Prototyping feedback",
      "Cross-functional collaboration",
      "Stakeholder review meetings"
    ],
    "correctIndex": 0,
    "explanation": "Requirements validation focuses on confirming the correctness and completeness of the requirements themselves, often through activities like prototyping feedback and stakeholder reviews. Debugging code errors, however, is a part of the *testing* and *implementation* phases of software development, occurring much later."
  },
  {
    "question": "Which of these techniques is best for understanding user pain points?",
    "choices": [
      "Observation",
      "Document analysis",
      "Brainstorming",
      "Surveys"
    ],
    "correctIndex": 0,
    "explanation": "Observation, particularly ethnographic observation, involves watching users perform their tasks in their natural environment. This direct method is highly effective for uncovering unspoken needs, identifying inefficiencies, and revealing actual 'pain points' that users might not explicitly articulate in interviews or surveys."
  },
  {
    "question": "In document analysis, what type of document is typically NOT analyzed?",
    "choices": [
      "Test case documents",
      "Stakeholder meeting notes",
      "User training guides",
      "Existing system manuals"
    ],
    "correctIndex": 0,
    "explanation": "Document analysis involves reviewing existing documentation to glean information about current processes, systems, and constraints. While existing system manuals, stakeholder meeting notes, and user training guides provide valuable context, 'test case documents' are typically an *output* of the requirements and design phases, rather than a source for initial analysis."
  },
  {
    "question": "Peer reviews and inspections are common methods of ____________.",
    "choices": [
      "Verification",
      "Validation",
      "Prioritization",
      "Risk analysis"
    ],
    "correctIndex": 0,
    "explanation": "Peer reviews and inspections are verification techniques focused on checking artifacts like requirements documents, design specifications, or code for defects and adherence to standards. They are systematic checks to ensure that the product is being built *correctly* according to the specifications."
  },
  {
    "question": "Which of the following is an example of a functional requirement?",
    "choices": [
      "Users must be able to reset their passwords via email.",
      "The system must process transactions in under 2 seconds.",
      "The database must support up to 10 million records.",
      "The system must be available 24/7."
    ],
    "correctIndex": 0,
    "explanation": "A functional requirement specifies a particular function or service that the system must perform. The ability for users to reset passwords via email is a direct statement of such a capability, contrasting with the non-functional aspects of performance, scalability, or availability."
  },
  {
    "question": "Which elicitation technique focuses on creating a shared understanding of system requirements among all stakeholders?",
    "choices": [
      "Workshops",
      "Surveys",
      "Prototyping",
      "Observation"
    ],
    "correctIndex": 0,
    "explanation": "Requirements workshops are highly collaborative sessions designed to bring together diverse stakeholders to discuss, clarify, and collectively agree upon system requirements. This interactive environment fosters a shared understanding and helps resolve ambiguities much more efficiently than individual elicitation methods."
  },
  {
    "question": "Functional requirements define \"what\" a system does, while non-functional requirements define \"how\" it performs.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. This distinction is fundamental in software engineering. Functional requirements describe the specific actions or services the system must provide (the 'what'), such as generating a report or processing a payment. Non-functional requirements, on the other hand, specify quality attributes and constraints (the 'how'), like performance speed, security levels, or usability."
  },
  {
    "question": "Non-functional requirements include performance, security, and scalability.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. Non-functional requirements (NFRs) are crucial attributes that define the quality and overall effectiveness of a system, but not its specific functions. Performance (e.g., response time), security (e.g., access control), and scalability (e.g., handling increased load) are all classic examples of NFRs that dictate how well the system operates."
  },
  {
    "question": "What is the primary purpose of a use case in UML?",
    "choices": [
      "To document functional requirements",
      "To define non-functional requirements",
      "To validate system performance",
      "To specify testing criteria"
    ],
    "correctIndex": 0,
    "explanation": "In UML, a use case serves as a technique to capture and document functional requirements from the user's perspective. Each use case describes a specific goal an actor achieves through interaction with the system, detailing the steps involved without specifying internal implementation."
  },
  {
    "question": "UML diagrams are essential for software design and development.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. Unified Modeling Language (UML) diagrams provide a standardized visual notation for specifying, visualizing, constructing, and documenting the artifacts of a software system. They are invaluable tools for communicating complex designs, analyzing requirements, and planning development, making them essential throughout the software lifecycle."
  },
  {
    "question": "What term describes the specific functionality provided by the system to satisfy user needs?",
    "choices": [
      "Functional requirement",
      "Non-functional requirement",
      "Design specification",
      "Validation criteria"
    ],
    "correctIndex": 0,
    "explanation": "A functional requirement explicitly describes a specific action or service that a software system must perform to meet a user's need. These requirements define the system's behavior and what it is supposed to do, such as 'The system shall allow users to log in'."
  },
  {
    "question": "What diagram type is best suited for showing object behaviors?",
    "choices": [
      "State diagram",
      "Component diagram",
      "Use case diagram",
      "Deployment diagram"
    ],
    "correctIndex": 0,
    "explanation": "A state diagram, or state machine diagram, is specifically designed to model the various states an object can have and the transitions between those states in response to events. This makes it ideal for depicting the dynamic behavior of individual objects over their lifetime."
  },
  {
    "question": "Which technique combines drawing and collaboration to create early models of a system?",
    "choices": [
      "Prototyping",
      "Use case diagrams",
      "Observation",
      "Data flow diagrams"
    ],
    "correctIndex": 0,
    "explanation": "Prototyping involves building early, incomplete versions of a system or specific features to gather feedback and refine requirements and design. It often includes drawing mockups or creating interactive models, fostering collaboration with stakeholders to visualize and validate ideas before full development."
  },
  {
    "question": "A use case diagram consists of actors, ________, and their relationships.",
    "choices": [
      "Use cases",
      "Classes",
      "Objects",
      "Components"
    ],
    "correctIndex": 0,
    "explanation": "A use case diagram is fundamentally composed of actors (external entities interacting with the system) and use cases (the functions or services the system provides to these actors). The lines connecting them represent the relationships and interactions that define the system's external behavior."
  },
  {
    "question": "Which of these best describes a class diagram?",
    "choices": [
      "It represents system structure and relationships between classes.",
      "It shows user interactions with the system.",
      "It depicts system states and transitions.",
      "It visualizes the modular components of the system."
    ],
    "correctIndex": 0,
    "explanation": "A class diagram is a foundational UML structural diagram that illustrates the static structure of a system. It shows the classes, their attributes, operations (methods), and the relationships between them, such as associations, generalizations, and dependencies, providing a blueprint for the system's data and behavior."
  },
  {
    "question": "Requirements validation focuses on ensuring the software will meet the user's expectations, while verification ensures that the software is built correctly.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. This statement accurately distinguishes between validation and verification. Validation answers the question 'Are we building the *right* product?' by ensuring requirements align with user needs. Verification answers 'Are we building the product *right*?' by checking if the software conforms to its specifications and standards."
  },
  {
    "question": "Which UML diagram best represents object interactions over time?",
    "choices": [
      "Sequence diagram",
      "Use case diagram",
      "Class diagram",
      "State diagram"
    ],
    "correctIndex": 0,
    "explanation": "A sequence diagram is a UML interaction diagram that visually represents the order of messages exchanged between objects or components over time. It's particularly useful for modeling the logic of a use case, showing the exact sequence of events that occur to achieve a specific outcome."
  },
  {
    "question": "Which of these requirements would fall under \"usability\"?",
    "choices": [
      "The user shall interact with an intuitive graphical interface.",
      "The system must validate passwords for security.",
      "The database must recover from crashes within 1 hour.",
      "The application must log user activities."
    ],
    "correctIndex": 0,
    "explanation": "Usability is a non-functional requirement that relates to how easy and pleasant a system is to use. An intuitive graphical interface directly addresses usability, aiming to minimize user effort and maximize user satisfaction when interacting with the software."
  },
  {
    "question": "Which of the following is a functional requirement?",
    "choices": [
      "The user shall log in with a username and password",
      "System uptime must be 99.9%",
      "The system should support 1000 simultaneous users",
      "Response time should not exceed 2 seconds"
    ],
    "correctIndex": 0,
    "explanation": "Functional requirements define specific behaviors or functions that a system must exhibit. The ability for a user to log in with credentials is a core functional aspect of many systems, dictating a particular interaction and outcome. The other options describe quality attributes, making them non-functional requirements."
  },
  {
    "question": "Which tool is commonly used in validation?",
    "choices": [
      "Prototyping tools",
      "Version control systems",
      "Integrated Development Environments (IDEs)",
      "Performance monitoring software"
    ],
    "correctIndex": 0,
    "explanation": "Prototyping tools are commonly used in the validation phase because they allow for the creation of mock-ups or partial implementations of the system. These prototypes can be presented to stakeholders and end-users to gather early feedback and confirm that the proposed requirements align with their actual needs and expectations."
  },
  {
    "question": "What is the role of a requirements traceability matrix in verification?",
    "choices": [
      "Maps requirements to corresponding test cases",
      "Tracks bugs in testing phases",
      "Ensures stakeholders agree on priorities",
      "Records meeting minutes"
    ],
    "correctIndex": 0,
    "explanation": "A requirements traceability matrix (RTM) is a powerful tool in verification as it establishes clear links between requirements and other artifacts like design elements, code modules, and especially test cases. This mapping ensures that every requirement is tested and that all tests cover specified functionalities, thereby verifying compliance and completeness."
  },
  {
    "question": "____________ is a group-based technique for generating ideas and clarifying requirements.",
    "choices": [
      "Brainstorming",
      "Focus groups",
      "Observation",
      "Interviews"
    ],
    "correctIndex": 0,
    "explanation": "Brainstorming is a dynamic group technique used to generate a large number of ideas in a short period, often to identify potential requirements or solutions. It encourages free thinking and collaboration among participants, helping to uncover diverse perspectives and clarify complex aspects of a system."
  },
  {
    "question": "What is the primary objective of focus groups in requirements elicitation?",
    "choices": [
      "To gather diverse stakeholder opinions",
      "To test software performance",
      "To validate system requirements",
      "To document user stories"
    ],
    "correctIndex": 0,
    "explanation": "Focus groups are a qualitative research method used to elicit a wide range of opinions, perceptions, and attitudes from a selected group of stakeholders. They facilitate discussion and interaction among participants, providing rich insights into their collective needs and perspectives on system requirements."
  },
  {
    "question": "In a use case diagram, ________ are the external entities interacting with the system.",
    "choices": [
      "Actors",
      "Components",
      "Classes",
      "Objects"
    ],
    "correctIndex": 0,
    "explanation": "In a use case diagram, 'actors' represent the roles that users or other external systems play when interacting with the system under consideration. They initiate use cases and are crucial for defining the boundaries and functionality of the system from an external perspective."
  },
  {
  "question": "____________ ensures that system requirements align with customer expectations.",
  "choices": [
    "Validation",
    "Verification",
    "Unit testing",
    "Design testing"
  ],
  "correctIndex": 0,
  "explanation": "Validation is the process of evaluating software during or at the end of the development process to determine whether it satisfies specified requirements. In the context of requirements, validation ensures that the gathered requirements truly reflect the needs and expectations of the customer and stakeholders, thereby confirming that 'we are building the right product.'"
  },
    {
    "question": "Which UML diagram is used to visualize the interaction between a system and external actors?",
    "choices": [
      "Use case diagram",
      "Deployment diagram",
      "Sequence diagram",
      "Activity diagram"
    ],
    "correctIndex": 0,
    "explanation": "A Use Case diagram provides a high-level visual representation of how users (actors) interact with a system to achieve specific goals. It focuses on the external behavior of the system, defining its boundaries and primary functions from the user's perspective."
  },
  {
    "question": "Which UML diagram is most suitable for showing the flow of control or data within a process?",
    "choices": [
      "Activity diagram",
      "Sequence diagram",
      "Use case diagram",
      "Class diagram"
    ],
    "correctIndex": 0,
    "explanation": "An Activity diagram is specifically designed to model the step-by-step flow of activities and decisions within a process or workflow. It is excellent for visualizing business processes, operational workflows, and the control flow of a system."
  },
  {
    "question": "A ________ diagram shows the flow of activities in a system and decision points.",
    "choices": [
      "Activity",
      "Sequence",
      "Use case",
      "Class"
    ],
    "correctIndex": 0,
    "explanation": "An Activity diagram is a behavioral diagram in UML that illustrates the flow of activities, actions, and decision points within a system. It's often used to model workflows, business processes, and the logic of complex operations."
  },
  {
    "question": "Which GRASP principle deals with assigning responsibility to ensure system behavior is controlled by a central entity?",
    "choices": [
      "Controller",
      "Creator",
      "Polymorphism",
      "Indirection"
    ],
    "correctIndex": 0,
    "explanation": "The Controller GRASP principle assigns the responsibility of handling system events (like user interface events or system operations) to a single, central object. This centralizes control, reducing coupling and making the system easier to manage and understand."
  },
  {
    "question": "What is the main advantage of using GRASP principles in software design?",
    "choices": [
      "They guide the assignment of responsibilities within a system",
      "They offer standardized testing tools",
      "They enhance software maintenance techniques",
      "They reduce hardware dependencies"
    ],
    "correctIndex": 0,
    "explanation": "GRASP (General Responsibility Assignment Software Patterns) principles are foundational guidelines for assigning responsibilities to classes and objects during object-oriented design. They help in creating highly cohesive and loosely coupled systems, leading to more maintainable, flexible, and understandable software."
  },
  {
    "question": "Which of the following is a principle of good software design?",
    "choices": [
      "High cohesion and low coupling",
      "High coupling and low cohesion",
      "High cohesion and high coupling",
      "Low cohesion and low coupling"
    ],
    "correctIndex": 0,
    "explanation": "Good software design aims for high cohesion (where elements within a module work closely together for a single, well-defined purpose) and low coupling (where modules are as independent as possible). This combination leads to systems that are easier to understand, test, maintain, and reuse."
  },
  {
    "question": "UML activity diagrams are used to model ________.",
    "choices": [
      "Workflow and decision-making processes",
      "The relationships between classes",
      "The interaction between objects",
      "Deployment strategies"
    ],
    "correctIndex": 0,
    "explanation": "UML Activity diagrams are specifically used to describe the dynamic aspects of a system, focusing on the flow of control from activity to activity. They are ideal for modeling workflows, business processes, and the decision logic within a system."
  },
  {
    "question": "________ diagrams are used in UML to describe the structure of a system.",
    "choices": [
      "Class",
      "Activity",
      "Sequence",
      "Use case"
    ],
    "correctIndex": 0,
    "explanation": "Class diagrams are fundamental structural diagrams in UML. They define the static structure of a system by showing its classes, their attributes, operations, and the relationships between them, such as associations, generalizations (inheritance), and dependencies."
  },
  {
    "question": "The principle of \"Separation of Concerns\" in software design aims to:",
    "choices": [
      "Separate different aspects of a program to reduce complexity",
      "Break down complex systems into unrelated components",
      "Divide a program into distinct features that overlap in functionality",
      "Ensure all modules share the same responsibilities"
    ],
    "correctIndex": 0,
    "explanation": "The Separation of Concerns principle advocates for dividing a system into distinct sections, each addressing a specific concern (or responsibility). This approach helps manage complexity, improves modularity, and makes the system easier to develop, test, and maintain."
  },
  {
    "question": "In the context of cohesion, what does \"functional cohesion\" mean?",
    "choices": [
      "All operations within a module contribute to a single task.",
      "A module focuses on unrelated tasks.",
      "A module uses global variables extensively.",
      "Operations in a module are unrelated."
    ],
    "correctIndex": 0,
    "explanation": "Functional cohesion is the highest and most desirable type of cohesion. It means that all elements (operations, attributes) within a module are essential for and contribute directly to performing a single, well-defined task or function, ensuring the module has a clear and focused purpose."
  },
  {
    "question": "Which GRASP principle focuses on creating reusable objects and reduces redundancy in the system?",
    "choices": [
      "Pure Fabrication",
      "Polymorphism",
      "Creator",
      "Information Expert"
    ],
    "correctIndex": 0,
    "explanation": "Pure Fabrication is a GRASP principle that suggests creating a class that does not represent a domain concept but is designed specifically to achieve high cohesion and low coupling. Such 'fabricated' classes are often highly reusable as they encapsulate specific behaviors that might otherwise be scattered or violate the Information Expert principle."
  },
  {
    "question": "In UML, what does a solid line with a filled arrowhead represent in a class diagram?",
    "choices": [
      "Generalization",
      "Dependency",
      "Aggregation",
      "Association"
    ],
    "correctIndex": 0,
    "explanation": "In a UML Class diagram, a solid line with a filled, triangular arrowhead pointing from the subclass to the superclass represents Generalization (inheritance). It signifies an 'is-a' relationship, where the subclass inherits properties and behaviors from the superclass."
  },
  {
    "question": "Which design pattern allows an object to change its behavior when its internal state changes?",
    "choices": [
      "State",
      "Singleton",
      "Decorator",
      "Observer"
    ],
    "correctIndex": 0,
    "explanation": "The State design pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class, as it encapsulates state-specific behavior into separate state classes, making it easier to manage complex state-dependent logic."
  },
  {
    "question": "What is the main goal of the Open-Closed Principle in software design?",
    "choices": [
      "Software entities should be open for extension but closed for modification.",
      "Software entities should depend on abstractions rather than concretions.",
      "Subclasses should replace parent classes without breaking functionality.",
      "Classes should have only one reason to change."
    ],
    "correctIndex": 0,
    "explanation": "The Open-Closed Principle (OCP) is a core SOLID principle stating that software entities (classes, modules, functions, etc.) should be open for extension (meaning new functionality can be added) but closed for modification (meaning existing code should not be changed). This promotes stable and maintainable codebases."
  },
  {
    "question": "________ diagrams in UML are used to show the runtime interaction between objects.",
    "choices": [
      "Sequence",
      "Use case",
      "Activity",
      "Class"
    ],
    "correctIndex": 0,
    "explanation": "Sequence diagrams are interaction diagrams in UML that depict the order of messages exchanged between objects or components in a system over time. They are excellent for visualizing the dynamic behavior and flow of control within a specific scenario or use case."
  },
  {
    "question": "The \"Information Expert\" GRASP principle assigns responsibilities to the class with the most information required.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. The Information Expert GRASP principle advocates assigning a responsibility to the class that has the necessary information to fulfill that responsibility. This principle leads to highly cohesive classes by keeping related data and behavior together."
  },
  {
    "question": "The ________ design principle encourages depending on abstractions rather than concretions.",
    "choices": [
      "Dependency Inversion",
      "Interface Segregation",
      "Single Responsibility",
      "Open-Closed"
    ],
    "correctIndex": 0,
    "explanation": "The Dependency Inversion Principle (DIP) is a SOLID principle that states high-level modules should not depend on low-level modules; both should depend on abstractions. Additionally, abstractions should not depend on details; details should depend on abstractions. This promotes flexible and loosely coupled architectures."
  },
  {
    "question": "What is the primary goal of minimizing coupling in a software system?",
    "choices": [
      "To make modules independent of each other",
      "To optimize system performance through tighter integration",
      "To ensure seamless communication between all components",
      "To simplify debugging by increasing modular interconnections"
    ],
    "correctIndex": 0,
    "explanation": "Minimizing coupling (loose coupling) means reducing the interdependencies between software modules. The primary goal is to make modules more independent, which improves reusability, testability, and maintainability, as changes in one module are less likely to impact others."
  },
  {
    "question": "The Singleton pattern can lead to issues in multithreaded environments if not implemented carefully.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. In a multithreaded environment, multiple threads might attempt to create an instance of a Singleton class simultaneously, leading to multiple instances being created (violating the pattern) if proper synchronization mechanisms (like locks or double-checked locking) are not used."
  },
  {
    "question": "The term \"tight coupling\" in software design means:",
    "choices": [
      "Modules are heavily dependent on one another",
      "Modules have distinct and well-defined boundaries",
      "Code can be reused across different systems",
      "Testing becomes easier"
    ],
    "correctIndex": 0,
    "explanation": "Tight coupling occurs when modules are highly interdependent, meaning changes in one module often necessitate changes in others. This makes the system more rigid, harder to understand, test, and maintain, and reduces reusability."
  },
  {
    "question": "What is the main benefit of using UML diagrams in software design?",
    "choices": [
      "They simplify communication among stakeholders.",
      "They eliminate the need for documentation.",
      "They enhance the runtime performance of software.",
      "They automate the testing process."
    ],
    "correctIndex": 0,
    "explanation": "UML diagrams provide a standardized visual language for modeling software systems. This visual representation significantly simplifies communication among developers, architects, business analysts, and other stakeholders, helping everyone understand the system's requirements, design, and behavior more effectively."
  },
  {
    "question": "Which UML diagram is most useful for representing object interactions over time?",
    "choices": [
      "Sequence diagram",
      "Class diagram",
      "Component diagram",
      "Deployment diagram"
    ],
    "correctIndex": 0,
    "explanation": "A Sequence diagram is an interaction diagram that shows the order in which messages are sent between objects. It emphasizes the time-ordered sequence of interactions, making it ideal for visualizing the dynamic behavior of a system or a specific scenario over time."
  },
  {
    "question": "The ________ pattern ensures that a class has only one instance and provides a global point of access to it.",
    "choices": [
      "Singleton",
      "Factory",
      "Observer",
      "Adapter"
    ],
    "correctIndex": 0,
    "explanation": "The Singleton design pattern restricts the instantiation of a class to a single object. It ensures that only one instance of the class exists throughout the application's lifecycle and provides a global access point to that instance."
  },
  {
    "question": "The Observer pattern allows one-to-many dependencies between objects.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. The Observer pattern defines a one-to-many dependency between objects so that when one object (the subject) changes state, all its dependents (observers) are notified and updated automatically. This pattern is fundamental for implementing distributed event handling systems."
  },
  {
    "question": "________ design principle states that a module should only have one reason to change.",
    "choices": [
      "Single Responsibility",
      "Open-Closed",
      "Liskov Substitution",
      "Dependency Inversion"
    ],
    "correctIndex": 0,
    "explanation": "The Single Responsibility Principle (SRP) is a SOLID principle that states a class or module should have only one reason to change. This means each module should be responsible for a single, well-defined piece of functionality, leading to more cohesive and maintainable code."
  },
  {
    "question": "Which software architecture pattern divides a system into three interconnected layers: Presentation, Application, and Data?",
    "choices": [
      "Layered architecture",
      "Event-driven architecture",
      "Microservices",
      "Model-View-Controller (MVC)"
    ],
    "correctIndex": 0,
    "explanation": "Layered architecture, often referred to as N-tier architecture, typically organizes a system into distinct horizontal layers, with the most common being Presentation (UI), Application (business logic), and Data (data access). Each layer has specific responsibilities and communicates only with the layers directly above and below it."
  },
  {
    "question": "The Adapter design pattern is used to convert the interface of a class into another interface the client expects.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. The Adapter design pattern (also known as Wrapper) acts as a bridge between two incompatible interfaces. It allows objects with incompatible interfaces to collaborate, converting the interface of one class into another interface clients expect, without changing the existing classes."
  },
  {
    "question": "________ patterns are templates for solving common design problems in software systems.",
    "choices": [
      "Design",
      "Architecture",
      "Workflow",
      "Behavioral"
    ],
    "correctIndex": 0,
    "explanation": "Design patterns are generalized, reusable solutions to common problems encountered during software design. They are not direct solutions but rather templates or blueprints that can be adapted to various situations to create robust, flexible, and maintainable software systems."
  },
  {
    "question": "Which UML diagram is primarily used to model the dynamic behavior of a system?",
    "choices": [
      "Sequence diagram",
      "Class diagram",
      "Component diagram",
      "Deployment diagram"
    ],
    "correctIndex": 0,
    "explanation": "Sequence diagrams are UML behavioral diagrams that illustrate the dynamic behavior of a system by showing the order of interactions between objects over time. They are crucial for understanding how objects collaborate to perform a specific function or use case."
  },
  {
    "question": "GitHub is a web-based platform for hosting and collaborating on _______ repositories.",
    "choices": [
      "Git",
      "Deployment",
      "Code review",
      "Backup"
    ],
    "correctIndex": 0,
    "explanation": "GitHub is built around the Git version control system. It provides a platform for hosting Git repositories and offers features for collaborative software development, such as issue tracking, pull requests, and code review."
  },
  {
    "question": "Waterfall is a better choice for projects where requirements are well-defined and unlikely to change.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. The Waterfall model's sequential and rigid nature makes it suitable for projects with stable and clearly defined requirements. Changes are difficult and costly to incorporate once a phase is complete."
  },
  {
    "question": "Agile methodology is more adaptable to changing requirements compared to Waterfall.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. Agile methodologies are designed to be flexible and adaptive. They embrace changing requirements throughout the development lifecycle, unlike Waterfall, which assumes requirements are fixed upfront."
  },
  {
    "question": "In Agile, what is the main purpose of a retrospective meeting?",
    "choices": [
      "To reflect on the previous sprint and improve processes",
      "To plan all future sprints in detail",
      "To finalize the requirements",
      "To freeze the scope of the project"
    ],
    "correctIndex": 0,
    "explanation": "The retrospective meeting in Agile (especially Scrum) is a dedicated time for the team to inspect how the last sprint went regarding people, relationships, processes, and tools. The goal is to identify what went well, what could be improved, and to create a plan for improvements in the next sprint."
  },
  {
    "question": "What is the purpose of iterative development in methodologies like Scrum?",
    "choices": [
      "To improve product quality through regular feedback",
      "To reduce team size",
      "To eliminate testing",
      "To avoid customer involvement"
    ],
    "correctIndex": 0,
    "explanation": "Iterative development, central to Scrum, involves developing the product in small, incremental cycles. Each iteration delivers a working increment of the product, allowing for frequent feedback from stakeholders, which in turn helps improve product quality and ensures it meets evolving needs."
  },
  {
    "question": "Which of the following commands initializes a new Git repository?",
    "choices": [
      "git init",
      "git add",
      "git clone",
      "git status"
    ],
    "correctIndex": 0,
    "explanation": "`git init` is the command used to create a new, empty Git repository or reinitialize an existing one. It creates the `.git` directory in the current working directory, which contains all the necessary Git files for the repository."
  },
  {
    "question": "Which of the following best describes the Waterfall model?",
    "choices": [
      "Linear and sequential process",
      "Flexible and iterative process",
      "Continuous delivery of working software",
      "Emphasis on collaboration and adaptability"
    ],
    "correctIndex": 0,
    "explanation": "The Waterfall model is characterized by its linear and sequential approach. Each phase (requirements, design, implementation, testing, deployment, maintenance) must be completed before the next one begins, with no overlapping or going back to previous phases."
  },
  {
    "question": "Waterfall is an iterative approach to software development.",
    "choices": [
      "False",
      "True"
    ],
    "correctIndex": 0,
    "explanation": "False. The Waterfall model is a linear-sequential approach, meaning each phase must be completed before the next begins. It is not iterative; iterations are a characteristic of Agile and other flexible methodologies."
  },
  {
    "question": "Which of the following is a significant benefit of Agile compared to Waterfall?",
    "choices": [
      "Faster delivery of working features",
      "Higher emphasis on documentation",
      "Clear definition of all requirements upfront",
      "Predictable schedules for all phases"
    ],
    "correctIndex": 0,
    "explanation": "Agile methodologies prioritize the frequent delivery of working software in small increments. This allows for earlier release of value to customers and faster feedback cycles, leading to more responsive development than the Waterfall model's 'big bang' release approach."
  },
  {
    "question": "The foundational principle of DevOps is to bridge the gap between software development and IT operations.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. DevOps aims to unite software development (Dev) and IT operations (Ops) by promoting communication, collaboration, and integration between these teams. The goal is to improve the speed, efficiency, and quality of software delivery."
  },
  {
    "question": "Which of the following is an official role defined within the Scrum framework?",
    "choices": [
      "Product Owner",
      "Project Coordinator",
      "Business Analyst",
      "Software Architect"
    ],
    "correctIndex": 0,
    "explanation": "Within the Scrum framework, there are three core roles: Product Owner, Scrum Master, and Development Team. The Project Coordinator, Business Analyst, and Software Architect are common roles in other methodologies but not explicitly defined as official Scrum roles."
  },
  {
    "question": "Git is a _______ system that tracks changes in source code during software development.",
    "choices": [
      "Version control",
      "Deployment",
      "Continuous integration",
      "Debugging"
    ],
    "correctIndex": 0,
    "explanation": "Git is a distributed version control system (DVCS). Its primary function is to track changes in source code and other files over time, allowing multiple developers to collaborate on a project, manage different versions, and revert to previous states if necessary."
  },
  {
    "question": "Extreme Programming (XP) emphasizes on:",
    "choices": [
      "Pair programming and frequent releases",
      "Extensive testing before coding",
      "Following strict deadlines",
      "Limited customer involvement"
    ],
    "correctIndex": 0,
    "explanation": "Extreme Programming (XP) is an Agile framework that emphasizes practices like pair programming (two developers working on one workstation), test-driven development (TDD), continuous integration, and frequent small releases to customers."
  },
  {
    "question": "The Waterfall model assumes that all requirements can be _______ before development begins.",
    "choices": [
      "Defined",
      "Tested",
      "Automated",
      "Deployed"
    ],
    "correctIndex": 0,
    "explanation": "A core assumption of the Waterfall model is that all project requirements can be fully and accurately defined, documented, and approved at the very beginning of the project before any design or development work commences."
  },
  {
    "question": "Which of the following is a characteristic of the Spiral Model?",
    "choices": [
      "Focus on risk analysis",
      "Rigid sequential phases",
      "Emphasis on documentation",
      "One-time delivery"
    ],
    "correctIndex": 0,
    "explanation": "The Spiral Model is a risk-driven software development process model. It emphasizes iterative cycles with each cycle focusing on identifying and mitigating risks. Risk analysis is a central activity throughout its phases."
  },
  {
    "question": "Which of the following is a key characteristic of the Agile approach?",
    "choices": [
      "Incremental and iterative delivery",
      "Sequential and rigid phases",
      "Focus on detailed upfront planning",
      "Limited customer involvement during development"
    ],
    "correctIndex": 0,
    "explanation": "Agile methodologies promote incremental and iterative development, delivering working software in small, frequent increments (e.g., sprints). This contrasts with sequential models and allows for continuous feedback and adaptation."
  },
  {
    "question": "What is the primary purpose of GitHub in software development?",
    "choices": [
      "Hosting and collaborating on code repositories",
      "Managing hardware resources",
      "Automating deployment pipelines",
      "Debugging applications"
    ],
    "correctIndex": 0,
    "explanation": "GitHub's primary purpose is to provide web-based hosting for version control using Git, enabling developers to store their code repositories, collaborate on projects, track changes, and manage contributions through features like pull requests."
  },
  {
    "question": "In Scrum, work is divided into time-boxed intervals called ______.",
    "choices": [
      "Sprints",
      "Milestones",
      "Iterations",
      "Phases"
    ],
    "correctIndex": 0,
    "explanation": "In Scrum, the development process is organized into fixed-length iterations called 'Sprints'. Sprints typically last from one to four weeks and result in a potentially shippable product increment."
  },
  {
    "question": "In Scrum, the main deliverable at the end of each sprint is:",
    "choices": [
      "A potentially shippable product increment",
      "Comprehensive project documentation",
      "A finalized project plan",
      "A list of unaddressed issues"
    ],
    "correctIndex": 0,
    "explanation": "The goal of each sprint in Scrum is to produce a 'potentially shippable product increment'. This means a piece of working software that is complete, tested, and ready to be released to users if desired, even if it's not the final product."
  },
  {
    "question": "The Agile approach emphasizes _______ over following a strict plan.",
    "choices": [
      "Responding to change",
      "Creating extensive documentation",
      "Minimizing collaboration",
      "Sequential development"
    ],
    "correctIndex": 0,
    "explanation": "One of the core values of the Agile Manifesto is 'Responding to change over following a plan'. Agile methodologies prioritize flexibility and adaptation to new information or changing requirements rather than strictly adhering to an initial, rigid plan."
  },
  {
    "question": "The Kanban methodology is primarily focused on:",
    "choices": [
      "Visualizing work and limiting work in progress",
      "Timeboxing tasks",
      "Pre-planned iterations",
      "Extensive documentation"
    ],
    "correctIndex": 0,
    "explanation": "Kanban's core practices include visualizing the workflow (e.g., using a Kanban board), limiting work in progress (WIP) to prevent bottlenecks, and managing flow to optimize throughput. It is a pull-based system, unlike Scrum's time-boxed sprints."
  },
  {
    "question": "Which of the following is a benefit of using Git in software development?",
    "choices": [
      "Tracking changes and enabling collaboration",
      "Automating project deployment",
      "Managing server configurations",
      "Debugging runtime errors"
    ],
    "correctIndex": 0,
    "explanation": "Git is a version control system primarily used for tracking changes to files and coordinating work among multiple people on a project. It allows developers to maintain different versions of code, revert to previous states, and merge contributions seamlessly, thus enabling effective collaboration."
  },
  {
    "question": "The Scrum Master is responsible for maximizing the value of the product.",
    "choices": [
      "False",
      "True"
    ],
    "correctIndex": 0,
    "explanation": "False. The Product Owner is responsible for maximizing the value of the product and the work of the Development Team. The Scrum Master is responsible for promoting and supporting Scrum, acting as a servant-leader to the team and removing impediments."
  },
  {
    "question": "In Scrum, what is the primary responsibility of the Product Owner?",
    "choices": [
      "Defining and prioritizing the product backlog",
      "Removing obstacles faced by the team",
      "Writing and testing code",
      "Designing the system architecture"
    ],
    "correctIndex": 0,
    "explanation": "The Product Owner is the sole person responsible for managing the Product Backlog. This includes clearly expressing Product Backlog items, ordering the items to best achieve goals and missions, and ensuring the Product Backlog is visible, transparent, and clear to all."
  },
  {
    "question": "In Agile methodology, what is a “Sprint”?",
    "choices": [
      "A defined period for completing specific work",
      "A testing phase",
      "A customer review meeting",
      "A team-building activity"
    ],
    "correctIndex": 0,
    "explanation": "In Agile frameworks like Scrum, a 'Sprint' is a short, time-boxed period (usually 1-4 weeks) during which a Scrum Team works to complete a specific set of work and produce a 'Done' increment of product."
  },
  {
    "question": "Which principle is central to the Agile Manifesto?",
    "choices": [
      "Customer collaboration over contract negotiation",
      "Comprehensive documentation over working software",
      "Processes and tools over individuals and interactions",
      "Following a plan over responding to change"
    ],
    "correctIndex": 0,
    "explanation": "The Agile Manifesto states: 'Customer collaboration over contract negotiation.' This emphasizes the importance of working closely with customers throughout the development process to ensure the product meets their evolving needs, rather than relying solely on upfront contractual agreements."
  },
  {
    "question": "In Git, what is a branch used for?",
    "choices": [
      "Developing features or fixes in isolation",
      "Deleting unnecessary files",
      "Backing up the repository",
      "Tracking hardware configurations"
    ],
    "correctIndex": 0,
    "explanation": "In Git, branches are used to create independent lines of development. They allow developers to work on new features, bug fixes, or experiments in isolation from the main codebase (e.g., `main` or `master` branch) without affecting its stability."
  },
  {
    "question": "The primary focus of the Agile methodology is to deliver _______.",
    "choices": [
      "Flexible and adaptive solutions",
      "Error-free software",
      "High-level architecture",
      "Pre-defined workflows"
    ],
    "correctIndex": 0,
    "explanation": "Agile methodologies prioritize delivering flexible and adaptive solutions that can evolve and respond to changes in requirements and market conditions. This is achieved through iterative development, continuous feedback, and collaboration."
  },
  {
    "question": "Which of the following methodologies focuses on continuous delivery and integration?",
    "choices": [
      "DevOps",
      "Agile",
      "Waterfall",
      "Spiral"
    ],
    "correctIndex": 0,
    "explanation": "DevOps is a set of practices that combines software development (Dev) and IT operations (Ops) to shorten the systems development life cycle and provide continuous delivery with high software quality. Continuous integration and continuous delivery (CI/CD) are foundational pillars of DevOps."
  },
  {
    "question": "What is a disadvantage of the Waterfall model compared to Agile?",
    "choices": [
      "Limited flexibility to accommodate changes",
      "Emphasis on customer collaboration",
      "Early testing phases",
      "Incremental delivery of software"
    ],
    "correctIndex": 0,
    "explanation": "A major disadvantage of the Waterfall model is its lack of flexibility. Once a phase is completed, it's difficult and costly to go back and make changes to requirements or design. Agile, in contrast, embraces change throughout the development process."
  },
  {
    "question": "Agile promotes frequent _______ with stakeholders to ensure the project meets their needs.",
    "choices": [
      "Communication",
      "Documentation",
      "Testing",
      "Deployment"
    ],
    "correctIndex": 0,
    "explanation": "Agile methodologies emphasize continuous and frequent communication with stakeholders (customers, users, product owners) to ensure that the developing product aligns with their evolving needs and expectations. This feedback loop is crucial for adaptation."
  },
  {
    "question": "In which approach are customers actively involved throughout the development process?",
    "choices": [
      "Agile",
      "Waterfall",
      "Spiral",
      "V-Model"
    ],
    "correctIndex": 0,
    "explanation": "Agile methodologies strongly advocate for continuous customer involvement. Customers (or their representatives, like Product Owners) are typically involved in sprint planning, reviews, and provide ongoing feedback, ensuring the product constantly meets their needs."
  },
  {
    "question": "In Scrum, the individual responsible for maximizing the value of the product is called the _______.",
    "choices": [
      "Product Owner",
      "Scrum Master",
      "Developer",
      "Tester"
    ],
    "correctIndex": 0,
    "explanation": "The Product Owner is the key stakeholder representative in Scrum. Their primary responsibility is to define and articulate the product vision and to maximize the value of the product and the work of the Development Team, primarily through managing the Product Backlog."
  },
  {
    "question": "In Test-Driven Development (TDD), why is writing tests before code beneficial?",
    "choices": [
      "It helps identify potential design flaws early in the process",
      "It ensures that the code will pass without any changes",
      "It guarantees faster code writing",
      "It eliminates the need for manual testing"
    ],
    "correctIndex": 0,
    "explanation": "Writing tests first in TDD forces developers to think about the requirements and the API design of the code before implementation. This 'design-first' approach often reveals potential design flaws, edge cases, or ambiguities in requirements early on, making them cheaper and easier to fix."
  },
  {
    "question": "The \"Green\" phase in TDD refers to:",
    "choices": [
      "Making the test pass",
      "Writing tests",
      "Refactoring code",
      "Deploying the application"
    ],
    "correctIndex": 0,
    "explanation": "TDD follows a 'Red-Green-Refactor' cycle. The 'Red' phase is writing a failing test. The 'Green' phase involves writing just enough code to make that failing test pass, quickly."
  },
  {
    "question": "What is the primary role of the tests written during the TDD process?",
    "choices": [
      "To verify individual units or components of the software",
      "To test the overall performance of the system",
      "To verify the system requirements",
      "To ensure that user interfaces are functional"
    ],
    "correctIndex": 0,
    "explanation": "The tests in TDD are typically unit tests, focusing on verifying the smallest testable parts of an application (individual functions, methods, or classes) in isolation. This granular testing ensures that each component works as expected before integration."
  },
  {
    "question": "Which type of software testing is performed after the development process and checks for defects in the integrated system?",
    "choices": [
      "Integration testing",
      "Unit testing",
      "System testing",
      "Acceptance testing"
    ],
    "correctIndex": 0,
    "explanation": "Integration testing is performed after unit testing. It focuses on testing the interfaces and interactions between integrated units (modules or components) to ensure they work together correctly as a group."
  },
  {
    "question": "A common tool used for TDD in Python is:",
    "choices": [
      "PyUnit",
      "Selenium",
      "Postman",
      "LoadRunner"
    ],
    "correctIndex": 0,
    "explanation": "PyUnit, often referred to as `unittest` in Python's standard library, is a widely used unit testing framework that follows the xUnit style (like JUnit for Java). It is a common choice for implementing TDD in Python."
  },
  {
    "question": "White-box testing focuses on ______ structures of the code.",
    "choices": [
      "Internal",
      "External",
      "Integrated",
      "Functional"
    ],
    "correctIndex": 0,
    "explanation": "White-box testing (also known as clear-box, glass-box, or structural testing) examines the internal structure, design, and implementation of the software. Testers use their knowledge of the code to design test cases that cover paths, branches, and statements within the code."
  },
  {
    "question": "Which of the following is a potential drawback of using Test-Driven Development (TDD)?",
    "choices": [
      "Code may become too tightly coupled",
      "Increased likelihood of missing edge cases",
      "Slower feedback loop in detecting errors",
      "A large number of redundant tests"
    ],
    "correctIndex": 0,
    "explanation": "While TDD generally leads to better design, a potential drawback is that if not done carefully, writing tests for every small component can sometimes lead to overly granular tests that tightly couple the test code to the implementation details, making refactoring harder. The other options are generally benefits of TDD or unrelated."
  },
  {
    "question": "Why is Test-Driven Development (TDD) beneficial in software development?",
    "choices": [
      "It ensures the development of code that meets requirements by testing functionality early",
      "It speeds up the development process by skipping testing phases",
      "It reduces the cost of testing by eliminating the need for automated tools",
      "It eliminates the need for code refactoring after testing"
    ],
    "correctIndex": 0,
    "explanation": "TDD forces developers to consider requirements and expected behavior upfront, leading to a clearer understanding of the desired functionality. By writing tests before code, it ensures that the code written directly addresses those requirements and provides continuous validation, catching bugs early."
  },
  {
    "question": "Regression testing ensures that:",
    "choices": [
      "New changes do not break existing functionality",
      "The software passes initial smoke tests",
      "User interface components are aligned",
      "Stress limits are adhered to"
    ],
    "correctIndex": 0,
    "explanation": "Regression testing is the process of re-running previously executed tests to ensure that new code changes, bug fixes, or feature additions have not negatively impacted existing functionality. Its purpose is to prevent regressions (new bugs in old features)."
  },
  {
    "question": "Which of the following testing types is considered a non-functional test?",
    "choices": [
      "Usability Testing",
      "Unit Testing",
      "Integration Testing",
      "Regression Testing"
    ],
    "correctIndex": 0,
    "explanation": "Non-functional testing evaluates the 'how' of a system (e.g., performance, security, usability, reliability), rather than the 'what' (functionality). Usability testing assesses how easy the software is to use, learn, and understand, making it a non-functional aspect. Unit, Integration, and Regression testing are primarily functional or related to functional aspects."
  },
  {
    "question": "The type of testing best suited for an automated testing tool like JUnit is:",
    "choices": [
      "Unit testing",
      "Load testing",
      "User acceptance testing",
      "Security testing"
    ],
    "correctIndex": 0,
    "explanation": "JUnit is a widely used unit testing framework for Java. It is designed to test individual units or components of code in isolation, making it perfectly suited for automated unit testing."
  },
  {
    "question": "Postponing testing to later stages in software development leads to the following consequences, except:",
    "choices": [
      "Decreased overall project time",
      "Increased cost of defect fixing",
      "Higher risk of missing critical defects",
      "More time available for feature development"
    ],
    "correctIndex": 0,
    "explanation": "Postponing testing *increases* overall project time and cost. It does not decrease it. Defects found later in the development lifecycle are significantly more expensive and time-consuming to fix because they might require changes across multiple integrated components. It also increases the risk of critical defects going unnoticed until late stages or even after deployment."
  },
  {
    "question": "Which of the following is a popular automated testing tool used for web application testing?",
    "choices": [
      "Selenium",
      "GitHub Actions",
      "Postman",
      "Jenkins"
    ],
    "correctIndex": 0,
    "explanation": "Selenium is a widely recognized and popular open-source framework specifically designed for automating web browser interactions, making it a key tool for web application testing, including functional, regression, and cross-browser testing."
  },
  {
    "question": "Which of the following is most likely to be impacted by the stage at which software testing is conducted in a project?",
    "choices": [
      "The cost of defect resolution",
      "The number of testers required",
      "The type of programming language used",
      "The number of user stories"
    ],
    "correctIndex": 0,
    "explanation": "The cost of defect resolution significantly increases the later a defect is found in the software development lifecycle. Bugs caught during unit testing are far cheaper to fix than those found during integration testing, system testing, or, most expensively, after deployment in production."
  },
  {
    "question": "______ testing is performed to validate the system's compliance with business requirements.",
    "choices": [
      "Acceptance",
      "Unit",
      "Regression",
      "System"
    ],
    "correctIndex": 0,
    "explanation": "Acceptance testing (often User Acceptance Testing - UAT) is a formal testing process conducted to verify that a system meets the specified business requirements and is acceptable for delivery. It's typically the final stage of functional testing before the system is released."
  },
  {
    "question": "The type of software testing that checks if the software functions according to the specified requirements is __________ testing.",
    "choices": [
      "Functional testing",
      "Performance testing",
      "Security testing",
      "Usability testing"
    ],
    "correctIndex": 0,
    "explanation": "Functional testing is a type of black-box testing that verifies software system features and functionality against the specified requirements. It answers the question 'Does the software do what it's supposed to do?'"
  },
  {
    "question": "Tests written in TDD serve as both validation and ______ for the code.",
    "choices": [
      "Documentation",
      "Verification",
      "Analysis",
      "Budget"
    ],
    "correctIndex": 0,
    "explanation": "In TDD, well-written tests act as executable documentation. They clearly demonstrate how a piece of code is expected to behave under various conditions, serving as a living specification of the system's requirements and functionality."
  },
  {
    "question": "Which of the following tools is most commonly used to ensure that code quality is maintained during development?",
    "choices": [
      "SonarQube",
      "JIRA",
      "Jenkins",
      "Selenium"
    ],
    "correctIndex": 0,
    "explanation": "SonarQube is a popular open-source platform designed for continuous inspection of code quality. It performs static analysis to detect bugs, code smells, and security vulnerabilities, helping developers maintain high code quality standards throughout the development process."
  },
  {
    "question": "Which of the following is the best practice in ensuring effective quality assurance in software development?",
    "choices": [
      "Integrating automated and manual testing early in the development process",
      "Focusing solely on functional testing to meet requirements",
      "Conducting manual tests only at the end of the project",
      "Using a single testing technique throughout the project"
    ],
    "correctIndex": 0,
    "explanation": "The most effective quality assurance integrates testing (both automated and manual) continuously and early into the software development lifecycle (Shift Left testing). This proactive approach helps detect and fix defects when they are least expensive to resolve and ensures continuous feedback on quality."
  },
  {
    "question": "TDD encourages developers to think about ______ before writing the actual code.",
    "choices": [
      "Requirements",
      "Test cases",
      "Functionality",
      "Implementation"
    ],
    "correctIndex": 0,
    "explanation": "TDD fundamentally shifts the focus to requirements and desired behavior. By writing a test first, developers are forced to clarify what the code should do (its requirements and functionality) and how it will be interacted with, before diving into the implementation details."
  },
  {
    "question": "To identify performance issues early in development, the most likely quality assurance process is:",
    "choices": [
      "Load testing",
      "Code reviews",
      "Regression testing",
      "Unit testing"
    ],
    "correctIndex": 0,
    "explanation": "Load testing (a type of performance testing) involves simulating a large number of users or transactions to determine how the system behaves under anticipated load. Doing this early in development helps identify performance bottlenecks and issues before they become critical."
  },
  {
    "question": "What does the \"refactor\" step in Test-Driven Development (TDD) primarily focus on?",
    "choices": [
      "Improving the quality of the code without changing its functionality",
      "Adding new tests for functionality",
      "Writing new feature requirements",
      "Removing all existing tests"
    ],
    "correctIndex": 0,
    "explanation": "After a test passes ('Green' phase), the 'Refactor' phase in TDD involves restructuring the code to improve its design, readability, maintainability, and efficiency without altering its external behavior or functionality. The existing tests serve as a safety net to ensure no functionality is broken during refactoring."
  },
  {
    "question": "Using an automated testing tool such as Selenium in a continuous integration (CI) environment speeds up the execution of repetitive test cases.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. Automated testing tools like Selenium are invaluable in CI/CD pipelines because they can run tests quickly and consistently every time code changes are integrated, significantly speeding up the feedback loop for repetitive and regression tests compared to manual execution."
  },
  {
    "question": "A key benefit of using automated testing tools in software development is:",
    "choices": [
      "Saving time on repetitive tests",
      "Early bug detection",
      "Simplifying the testing process",
      "Reducing long-term testing costs"
    ],
    "correctIndex": 0,
    "explanation": "While automated testing offers several benefits, one of its most prominent advantages is the significant time savings achieved by automating repetitive and regression tests. Once written, these tests can be run quickly and frequently without human intervention."
  },
  {
    "question": "The earlier a defect is found, the cheaper it is to fix.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. This is a widely accepted principle in software engineering. Defects found in early stages (e.g., requirements, design, unit testing) are typically much cheaper and easier to fix than those found later (e.g., system testing, acceptance testing, or production), as late-stage fixes often require extensive rework across integrated components."
  },
  {
    "question": "The cost of fixing a defect ______ as it is discovered later in the development lifecycle.",
    "choices": [
      "Increases",
      "Decreases",
      "Remains constant",
      "Is negligible"
    ],
    "correctIndex": 0,
    "explanation": "The cost of fixing a defect escalates significantly the later it is discovered. A bug found during unit testing might take minutes or hours to fix, while the same bug found in production could take days or weeks, involving deployment, patches, and potential reputation damage."
  },
  {
    "question": "Which of the following best describes an effective quality assurance (QA) process in agile development?",
    "choices": [
      "QA is integrated continuously throughout the development process",
      "QA is conducted only at the end of each sprint",
      "QA is handled by a separate team from the developers",
      "QA only focuses on performance testing"
    ],
    "correctIndex": 0,
    "explanation": "In Agile, QA is not a separate phase at the end but an ongoing activity. Testing and quality checks are integrated into every stage and conducted continuously within each sprint. This 'whole team' approach means developers, testers, and product owners collaborate on quality from the outset."
  },
  {
    "question": "In Test-Driven Development (TDD), which of the following is the correct order of steps?",
    "choices": [
      "Write tests, write code, refactor code",
      "Write code, write tests, refactor code",
      "Write tests, refactor code, write code",
      "Write code, refactor code, write tests"
    ],
    "correctIndex": 0,
    "explanation": "The TDD cycle is often described as 'Red, Green, Refactor'. This translates to: 1. Write a failing test (Red). 2. Write just enough code to make the test pass (Green). 3. Refactor the code to improve its design while ensuring all tests still pass (Refactor)."
  },
  {
    "question": "What is the primary limitation of automated testing tools?",
    "choices": [
      "They may not handle complex UI or visual elements well",
      "They cannot be used for functional testing",
      "They require fewer resources than manual testing",
      "They are not scalable in large systems"
    ],
    "correctIndex": 0,
    "explanation": "While highly effective for repetitive and logical tests, automated testing tools often struggle with tasks that require human judgment, such as assessing the aesthetics, usability, or subjective user experience of complex UIs. Visual validation, accessibility, and exploratory testing often still require manual intervention."
  },
  {
    "question": "Which testing approach is the most cost-effective if defects are detected during the early development stages?",
    "choices": [
      "Unit testing",
      "Regression testing",
      "Beta testing",
      "System testing"
    ],
    "correctIndex": 0,
    "explanation": "Unit testing is performed very early in the development lifecycle, typically by developers, to test individual components or units of code in isolation. Defects found at this granular level are the cheapest to fix because they are localized and haven't propagated through the system."
  },
  {
    "question": "Which principle is central to TDD?",
    "choices": [
      "Writing tests first",
      "Writing code before tests",
      "Skipping test cases for simple functionalities",
      "Writing documentation before tests"
    ],
    "correctIndex": 0,
    "explanation": "The core principle of TDD is to 'Test-First'. This means writing an automated test for a small piece of functionality before writing the actual code that implements that functionality."
  },
  {
    "question": "Which QA activity is typically performed after the software is fully developed to ensure that it behaves as expected in a production environment?",
    "choices": [
      "User acceptance testing",
      "Load testing",
      "Regression testing",
      "Static code analysis"
    ],
    "correctIndex": 0,
    "explanation": "User Acceptance Testing (UAT) is one of the final stages of software testing, where actual end-users or clients test the software to ensure it meets their requirements and can support daily business operations in a real-world scenario."
  },
  {
    "question": "Which of the following is true about automated testing tools?",
    "choices": [
      "They are effective at running repetitive tests and regression tests quickly.",
      "They are most beneficial when applied only during the final testing phase.",
      "They replace the need for manual testing entirely.",
      "They cannot be used for performance testing."
    ],
    "correctIndex": 0,
    "explanation": "Automated testing tools excel at efficiently executing repetitive tests (like regression tests) and providing quick feedback. They are not meant to replace all manual testing but rather to complement it, focusing on areas where automation provides the most value."
  },
  {
    "question": "What is \"code churn\" in software metrics?",
    "choices": [
      "Measurement of code changes over time",
      "Total lines of code in the system",
      "The number of tests performed",
      "User satisfaction levels"
    ],
    "correctIndex": 0,
    "explanation": "Code churn, also known as code volatility, refers to the rate at which code is added, deleted, or modified over a period. It's a metric that indicates the instability or activity of a codebase, often used in software quality and project management."
  },
  {
    "question": "Which of the following is a key goal of software maintenance?",
    "choices": [
      "Enhancing software performance",
      "Designing new software",
      "Eliminating software entirely",
      "Avoiding software updates"
    ],
    "correctIndex": 0,
    "explanation": "Software maintenance involves activities to modify and update software after delivery to correct faults, improve performance or other attributes, or adapt it to a changed environment. Enhancing performance is a type of perfective maintenance."
  },
  {
    "question": "Which of the following tools is most commonly used for issue tracking in maintenance?",
    "choices": [
      "Jira",
      "Excel",
      "Photoshop",
      "VLC Player"
    ],
    "correctIndex": 0,
    "explanation": "Jira is a widely used proprietary issue tracking product, developed by Atlassian. It provides bug tracking, issue tracking, and project management functions. Excel is a spreadsheet, Photoshop is for image editing, and VLC Player is a media player."
  },
  {
    "question": "What is a key benefit of software reengineering?",
    "choices": [
      "Enhancing system maintainability and performance",
      "Reducing project costs",
      "Increasing system redundancy",
      "Avoiding documentation"
    ],
    "correctIndex": 0,
    "explanation": "Software reengineering aims to restructure and modify an existing system to improve its quality attributes like maintainability, performance, or portability, without necessarily changing its core functionality. It is often done to extend the lifespan of legacy systems."
  },
  {
    "question": "What role does version control play in software maintenance?",
    "choices": [
      "Tracking changes and managing versions",
      "Deleting old versions",
      "Avoiding updates",
      "Enhancing hardware"
    ],
    "correctIndex": 0,
    "explanation": "Version control systems (VCS) like Git are crucial in software maintenance for tracking every change made to the codebase, enabling developers to revert to previous versions, merge changes from different branches, and collaborate effectively. This is vital for managing bug fixes and new features."
  },
  {
    "question": "Identify the main purpose of software reengineering.",
    "choices": [
      "Improving software structure and functionality",
      "Rewriting entire codebases",
      "Avoiding maintenance tasks",
      "Reducing user involvement"
    ],
    "correctIndex": 0,
    "explanation": "Software reengineering primarily focuses on understanding and then improving the internal structure, design, and often the functionality of existing software systems without discarding the current system entirely. It's about rejuvenation, not starting from scratch."
  },
  {
    "question": "Software reengineering involves restructuring existing code to improve maintainability and performance.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. This is the core definition and goal of software reengineering. It takes existing code and transforms it to enhance its quality attributes, such as maintainability, understandability, and performance, without changing its external behavior."
  },
  {
    "question": "Corrective maintenance focuses solely on adding new features to the software, ignoring bug fixes or error correction.",
    "choices": [
      "False",
      "True"
    ],
    "correctIndex": 0,
    "explanation": "False. Corrective maintenance is specifically concerned with fixing defects, bugs, and errors discovered after the software has been deployed. Adding new features falls under perfective maintenance."
  },
  {
    "question": "What is perfective maintenance?",
    "choices": [
      "Enhancing system performance and functionalities",
      "Fixing bugs and errors",
      "Adapting software to new environments",
      "Removing obsolete components"
    ],
    "correctIndex": 0,
    "explanation": "Perfective maintenance involves improving the software's functionality, efficiency, or other quality attributes based on user feedback or evolving requirements, such as adding new features, enhancing performance, or improving usability."
  },
  {
    "question": "In configuration management, version control systems help track _______ made to the software over time.",
    "choices": [
      "changes",
      "errors",
      "licenses",
      "backups"
    ],
    "correctIndex": 0,
    "explanation": "Version control systems are a fundamental component of configuration management, designed to record and manage all changes made to source code, documentation, and other project assets throughout the software development lifecycle."
  },
  {
    "question": "A maintenance backlog is:",
    "choices": [
      "A list of pending maintenance tasks",
      "A completed project",
      "Documentation storage",
      "Redundant features"
    ],
    "correctIndex": 0,
    "explanation": "A maintenance backlog is a prioritized list of tasks that need to be addressed in the software, including bug fixes, enhancements, and other modifications. It's continuously managed and refined."
  },
  {
    "question": "How does automation benefit software maintenance?",
    "choices": [
      "It reduces human error and speeds up processes",
      "It eliminates developer roles",
      "It adds complexity to systems",
      "It avoids documentation"
    ],
    "correctIndex": 0,
    "explanation": "Automation in software maintenance (e.g., automated testing, deployment, monitoring) significantly reduces the likelihood of human errors, accelerates repetitive tasks, and ensures consistency, thereby making the maintenance process more efficient and reliable."
  },
  {
    "question": "What does \"technical debt\" refer to in software measurement?",
    "choices": [
      "Shortcuts taken during development that require future fixes",
      "Financial cost of software",
      "User satisfaction levels",
      "Total size of the software"
    ],
    "correctIndex": 0,
    "explanation": "Technical debt is a metaphor reflecting the implied cost of additional rework caused by choosing an easy (limited) solution now instead of using a better approach that would take longer. It often stems from shortcuts or suboptimal design decisions that accumulate interest in the form of increased maintenance effort later."
  },
  {
    "question": "Why is modular design essential for software maintenance?",
    "choices": [
      "It simplifies updates and fixes",
      "It makes the software harder to understand",
      "It eliminates all bugs",
      "It avoids collaboration"
    ],
    "correctIndex": 0,
    "explanation": "Modular design breaks down software into smaller, independent, and loosely coupled modules. This makes it easier to understand, test, update, and fix individual parts without affecting the entire system, significantly simplifying the maintenance process."
  },
  {
    "question": "Which phase of software reengineering involves analyzing the current system?",
    "choices": [
      "Reverse engineering",
      "Forward engineering",
      "Maintenance",
      "Testing"
    ],
    "correctIndex": 0,
    "explanation": "Reverse engineering is the initial phase of software reengineering, where the existing system is analyzed to understand its components, relationships, and design. This understanding is crucial before any restructuring or modification (forward engineering) can begin."
  },
  {
    "question": "What is reverse engineering in software development?",
    "choices": [
      "Analyzing and understanding existing systems",
      "Creating new systems from scratch",
      "Avoiding system documentation",
      "Developing prototypes"
    ],
    "correctIndex": 0,
    "explanation": "Reverse engineering in software development is the process of examining a system to identify its components and their interrelationships, and to create representations of the system in another form or at a higher level of abstraction. Its goal is to understand how the system works, often without original design documents."
  },
  {
    "question": "Which metric is often used to assess code quality?",
    "choices": [
      "Maintainability Index",
      "Lines of Code (LOC)",
      "MTTR",
      "Story Points"
    ],
    "correctIndex": 0,
    "explanation": "The Maintainability Index is a software metric that measures how easy it is to maintain code. It's typically calculated based on factors like cyclomatic complexity, lines of code, and Halstead volume, providing a composite score indicating the code's maintainability."
  },
  {
    "question": "Software maintenance involves applying changes such as fixing bugs, improving functionality, and enhancing performance to ensure the software remains _______. ",
    "choices": [
      "operational",
      "deprecated",
      "incomplete",
      "inaccessible"
    ],
    "correctIndex": 0,
    "explanation": "The overarching goal of software maintenance is to ensure the software continues to be effective and useful. This means keeping it operational, performing correctly, meeting evolving user needs, and adapting to new environments."
  },
  {
    "question": "Software estimation techniques are only useful during initial development and have no role in maintenance projects.",
    "choices": [
      "False",
      "True"
    ],
    "correctIndex": 0,
    "explanation": "False. Software estimation techniques are crucial for maintenance projects as well. They help in predicting the effort, cost, and schedule required for bug fixes, enhancements, and other modifications, enabling better planning and resource allocation for ongoing support."
  },
  {
    "question": "Choose the correct definition of forward engineering in software reengineering.",
    "choices": [
      "Creating new systems from analyzed data",
      "Reverting changes made to software",
      "Simplifying code without modification",
      "Eliminating old systems"
    ],
    "correctIndex": 0,
    "explanation": "Forward engineering in the context of reengineering refers to the process of developing a new or improved version of a system, often based on the understanding gained from reverse engineering the old system. It involves creating detailed designs and implementing new code."
  },
  {
    "question": "In the context of software maintenance, what is the primary purpose of effort estimation?",
    "choices": [
      "Optimizing resource utilization and timeline accuracy",
      "Managing potential risks and unforeseen costs",
      "Prioritizing and planning required modifications",
      "Streamlining feature implementation and innovation"
    ],
    "correctIndex": 0,
    "explanation": "Effort estimation in software maintenance is primarily about accurately predicting the human resources and time required to complete maintenance tasks (bug fixes, enhancements). This enables efficient planning, resource allocation, and setting realistic timelines for project completion."
  },
  {
    "question": "Which technique is widely used for size estimation in software projects?",
    "choices": [
      "Function Point Analysis (FPA)",
      "Prototyping",
      "Agile Development",
      "Static Analysis"
    ],
    "correctIndex": 0,
    "explanation": "Function Point Analysis (FPA) is a widely recognized and standardized method for measuring the functional size of a software system. It measures functionality from the user's perspective, independent of the technology used, making it useful for estimation across different projects and phases."
  },
  {
    "question": "What does refactoring involve?",
    "choices": [
      "Improving code structure without changing functionality",
      "Adding new features",
      "Removing old systems",
      "Avoiding updates"
    ],
    "correctIndex": 0,
    "explanation": "Refactoring is the process of altering the internal structure of code without changing its external behavior. The goal is to improve non-functional attributes of the software, such as readability, maintainability, and efficiency, making it easier to understand and cheaper to modify in the future."
  },
  {
    "question": "A key best practice in software maintenance is conducting regular _______ testing to ensure that new changes do not negatively impact existing features.",
    "choices": [
      "regression",
      "exploratory",
      "unit",
      "acceptance"
    ],
    "correctIndex": 0,
    "explanation": "Regression testing is crucial in software maintenance to ensure that any new changes (bug fixes, enhancements, or adaptations) do not introduce new defects or reintroduce old ones into existing, previously functional parts of the software. It guards against unintended side effects."
  },
  {
    "question": "Configuration management ensures that changes to the software are made without tracking their impact or maintaining version control.",
    "choices": [
      "False",
      "True"
    ],
    "correctIndex": 0,
    "explanation": "False. The very purpose of configuration management is to systematically manage, organize, and control changes made to the software product throughout its lifecycle, including tracking their impact and maintaining strict version control. It's about ensuring order and traceability in change management."
  },
  {
    "question": "What is software measurement?",
    "choices": [
      "Quantifying attributes of software",
      "Writing documentation",
      "Deleting redundant code",
      "Conducting user interviews"
    ],
    "correctIndex": 0,
    "explanation": "Software measurement is the process of quantitatively assessing the attributes of software, such as its size, complexity, quality, reliability, and the effort or cost involved in its development and maintenance. It provides data for better decision-making and process improvement."
  },
  {
    "question": "_______ tool is widely used for configuration management.",
    "choices": [
      "Git",
      "Photoshop",
      "Excel",
      "VLC Player"
    ],
    "correctIndex": 0,
    "explanation": "Git is the most widely used distributed version control system (VCS), which is a core component of software configuration management (SCM). It enables developers to track changes, collaborate on code, and manage different versions of software projects."
  },
  {
    "question": "Why is configuration management critical in software maintenance?",
    "choices": [
      "It ensures consistency and control over system changes",
      "It eliminates testing requirements",
      "It automates user feedback collection",
      "It simplifies interface design"
    ],
    "correctIndex": 0,
    "explanation": "Configuration management is critical in maintenance because it provides a structured approach to managing changes to the software. It ensures that all modifications are tracked, versions are controlled, and consistent baselines are maintained, which is essential for long-term stability and controlled evolution of the system."
  },
  {
    "question": "Which metric measures software complexity?",
    "choices": [
      "Cyclomatic complexity",
      "Lines of code (LOC)",
      "Effort estimation",
      "Response time"
    ],
    "correctIndex": 0,
    "explanation": "Cyclomatic complexity is a quantitative measure of the number of linearly independent paths through a program's source code. It is often used as a metric for the complexity of a program, indicating the effort required for testing and maintenance."
  },
  {
    "question": "Software size estimation methods like Function Point Analysis help measure the scope of maintenance projects.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. Methods like Function Point Analysis (FPA) are not only for initial development but can also be adapted to estimate the size and effort of maintenance projects, particularly when adding new functionality or making significant enhancements. They help quantify the scope of changes."
  },
  {
    "question": "What does \"Mean Time to Repair\" (MTTR) measure?",
    "choices": [
      "Average time to fix a failure",
      "Total time for software testing",
      "Development time for new features",
      "Time spent in meetings"
    ],
    "correctIndex": 0,
    "explanation": "Mean Time to Repair (MTTR) is a maintenance metric that represents the average time required to repair a failed system or component and restore it to full functionality. It includes the time spent on diagnosis, repair, and testing."
  },
  {
    "question": "Why is code restructuring performed during reengineering?",
    "choices": [
      "To improve code readability and efficiency",
      "To increase system size",
      "To delete unused modules",
      "To reduce development time"
    ],
    "correctIndex": 0,
    "explanation": "Code restructuring during reengineering aims to improve the internal quality of the code. This includes making it more readable, understandable, maintainable, and potentially more efficient, without changing its external behavior."
  },
  {
    "question": "Define the role of a baseline in measurement.",
    "choices": [
      "Comparing current metrics with past data",
      "Starting new software projects",
      "Avoiding historical data",
      "Designing new systems"
    ],
    "correctIndex": 0,
    "explanation": "A baseline in measurement is a defined reference point or standard against which future measurements can be compared. In software, it allows for tracking progress, identifying trends, and assessing the impact of changes by comparing current metrics against a previously established baseline."
  },
  {
    "question": "Which of the following is an example of an ethical concern in software engineering?",
    "choices": [
      "Protecting user privacy and data security",
      "Maximizing code efficiency",
      "Reducing the size of the software",
      "Ensuring the software runs on multiple platforms"
    ],
    "correctIndex": 0,
    "explanation": "Ethical concerns in software engineering revolve around the moral implications of technology and its impact on society. Protecting user privacy and data security is a primary ethical responsibility, as a failure to do so can lead to significant harm."
  },
  {
    "question": "The first step in secure software development is______________.",
    "choices": [
      "Threat modeling",
      "Deployment",
      "Documentation",
      "User testing"
    ],
    "correctIndex": 0,
    "explanation": "Threat modeling is the first and most crucial step in a secure software development lifecycle. It involves identifying potential threats and vulnerabilities to the system and then planning countermeasures to mitigate those risks before any code is written."
  },
  {
    "question": "Secure software development lifecycle (SDLC) includes:",
    "choices": [
      "Planning, design, implementation, testing, deployment",
      "Planning, testing, marketing",
      "Design, advertising, sales",
      "Implementation, documentation, sales"
    ],
    "correctIndex": 0,
    "explanation": "The secure SDLC integrates security considerations into every phase of the traditional SDLC. This includes security-focused activities during planning, design, implementation (coding), testing, and deployment to ensure a holistic approach to security."
  },
  {
    "question": "What is a security patch?",
    "choices": [
      "An update to address vulnerabilities",
      "A bug-fixing update",
      "A feature enhancement",
      "A performance improvement"
    ],
    "correctIndex": 0,
    "explanation": "A security patch is a software update specifically designed to fix or 'patch' a known security vulnerability or a bug that could be exploited by an attacker. It is a critical part of maintaining the security of an application post-release."
  },
  {
    "question": "Which of the following is an example of regulatory compliance in software development?",
    "choices": [
      "Encrypting sensitive data as per legal requirements",
      "Ensuring the software is optimized for performance",
      "Ensuring the software meets accessibility standards",
      "Allowing users to modify the software code"
    ],
    "correctIndex": 0,
    "explanation": "Regulatory compliance refers to adhering to laws and regulations, such as GDPR or HIPAA. Encrypting sensitive data to meet legal requirements is a direct example of compliance, as it's often mandated by these laws to protect user data."
  },
  {
    "question": "A well-implemented security system in software development has no impact on the overall performance of the software.",
    "choices": [
      "FALSE",
      "TRUE"
    ],
    "correctIndex": 0,
    "explanation": "FALSE. Security measures, such as encryption, logging, and extensive validation, can add overhead and thus impact software performance. The goal of secure software development is to find an optimal balance between security and performance, not to eliminate performance impacts entirely."
  },
  {
    "question": "What is the primary purpose of ethics in software engineering?",
    "choices": [
      "To ensure fairness, accountability, and transparency",
      "To maximize profit",
      "To develop faster software",
      "To reduce the cost of software development"
    ],
    "correctIndex": 0,
    "explanation": "The primary purpose of ethics in software engineering is to guide professionals in making responsible decisions that prioritize the public good. This includes ensuring fairness in algorithms, holding themselves accountable for the software's impact, and maintaining transparency in its operation and data usage."
  },
  {
    "question": "The most important reason for implementing secure coding practices in software engineering is:",
    "choices": [
      "To prevent unauthorized access and data breaches",
      "To make the software faster",
      "To increase software complexity",
      "To improve the software’s user interface"
    ],
    "correctIndex": 0,
    "explanation": "Secure coding practices are designed to prevent security vulnerabilities that could be exploited by attackers. The most critical outcome of these practices is to protect the system from unauthorized access, data breaches, and other malicious activities."
  },
  {
    "question": "Identify the purpose of input validation.",
    "choices": [
      "To prevent malicious data from being processed",
      "To ensure software runs faster",
      "To encrypt data",
      "To make software user-friendly"
    ],
    "correctIndex": 0,
    "explanation": "Input validation is a fundamental security measure that checks, cleans, and filters user input to ensure it is safe and expected. Its purpose is to prevent attackers from injecting malicious data (like SQL injection or XSS attacks) that could compromise the system."
  },
  {
    "question": "Which of the following is a key feature of \"Role-Based Access Control\" (RBAC)?",
    "choices": [
      "Assigning permissions based on user roles",
      "Unlimited user permissions",
      "Denying access to all users",
      "No control over user actions"
    ],
    "correctIndex": 0,
    "explanation": "Role-Based Access Control (RBAC) is an access control mechanism where permissions are assigned to specific user roles (e.g., 'admin', 'user', 'guest'). Users are then granted permissions based on the role they are assigned, simplifying access management and enforcing the principle of least privilege."
  },
  {
    "question": "Which technique ensures data is protected during transmission?",
    "choices": [
      "Encryption",
      "Compression",
      "File Sharing",
      "Tokenization"
    ],
    "correctIndex": 0,
    "explanation": "Encryption is the process of converting data into a code to prevent unauthorized access. When data is transmitted, techniques like SSL/TLS encryption are used to protect it from being intercepted and read by unauthorized parties."
  },
  {
    "question": "Releasing incomplete software knowingly is an ethical practice if it saves costs.",
    "choices": [
      "FALSE",
      "TRUE"
    ],
    "correctIndex": 0,
    "explanation": "FALSE. Releasing incomplete software, especially if it contains known security flaws or is unstable, is considered unethical. It can harm users, compromise their data, and erode trust in the developer and the software. Cost-saving is not a justification for knowingly releasing a flawed product."
  },
  {
    "question": "Which is an example of secure coding practice?",
    "choices": [
      "Encrypting sensitive data",
      "Ignoring logging errors",
      "Using default passwords",
      "Hardcoding API keys in the source code"
    ],
    "correctIndex": 0,
    "explanation": "Encrypting sensitive data, both at rest and in transit, is a core secure coding practice. It ensures that even if data is stolen, it remains unreadable to an attacker. The other options are examples of insecure practices."
  },
  {
    "question": "Input validation is a critical step in preventing security vulnerabilities.",
    "choices": [
      "TRUE",
      "FALSE"
    ],
    "correctIndex": 0,
    "explanation": "TRUE. Input validation is a fundamental and critical security practice. By ensuring that all user-provided data is properly checked and sanitized, developers can prevent a wide range of common attacks, including SQL injection, Cross-Site Scripting (XSS), and buffer overflows."
  },
  {
    "question": "Which of the following is a secure authentication method?",
    "choices": [
      "Using multi-factor authentication",
      "Storing plaintext passwords",
      "Sharing credentials via email",
      "Hardcoding passwords in scripts"
    ],
    "correctIndex": 0,
    "explanation": "Multi-factor authentication (MFA) is a secure method that requires users to provide two or more verification factors to gain access to a resource. This significantly increases security by making it much harder for an attacker to compromise an account even if they have one credential."
  },
  {
    "question": "Why is ethical consideration important in software engineering?",
    "choices": [
      "To ensure societal trust in technology",
      "To meet user expectations",
      "To reduce software costs",
      "To avoid testing"
    ],
    "correctIndex": 0,
    "explanation": "Ethical considerations are vital because software has a profound impact on society. By acting ethically, software engineers build and maintain public trust, ensuring that technology is developed and used in a way that benefits humanity and avoids potential harm."
  },
  {
    "question": "What does \"CIA Triad\" in software security stand for?",
    "choices": [
      "Confidentiality, Integrity, Availability",
      "Control, Identification, Authentication",
      "Compliance, Integration, Assessment",
      "Configuration, Implementation, Access"
    ],
    "correctIndex": 0,
    "explanation": "The CIA Triad is a foundational model for software security. It represents the three main goals of information security: Confidentiality (protecting data from unauthorized access), Integrity (ensuring data is accurate and not tampered with), and Availability (making sure the system is accessible when needed)."
  },
  {
    "question": "What is an example of a secure coding principle?",
    "choices": [
      "Validating all inputs",
      "Using default passwords",
      "Avoiding code reviews",
      "Writing unstructured code"
    ],
    "correctIndex": 0,
    "explanation": "Validating all inputs is a key secure coding principle. It is a defense-in-depth strategy that prevents many common vulnerabilities by ensuring that any data entering the system is in a safe and expected format before it is processed."
  },
  {
    "question": "What is Cross-Site Scripting (XSS)?",
    "choices": [
      "Injecting malicious scripts into a trusted website",
      "Encrypting user data on the server",
      "Exploiting a vulnerability in web browsers",
      "Overloading server resources"
    ],
    "correctIndex": 0,
    "explanation": "Cross-Site Scripting (XSS) is a type of web security vulnerability where an attacker injects malicious client-side scripts into a website viewed by other users. These scripts can then be used to steal session cookies, deface websites, or redirect users."
  },
  {
    "question": "What is the purpose of threat modeling in software security?",
    "choices": [
      "Identifying potential vulnerabilities and mitigating them",
      "Designing user interfaces",
      "Enhancing software performance",
      "Testing software for usability"
    ],
    "correctIndex": 0,
    "explanation": "Threat modeling is a structured process used to identify, analyze, and prioritize potential security threats to a system. Its purpose is to proactively find vulnerabilities and design appropriate mitigations early in the development lifecycle."
  },
  {
    "question": "What is the purpose of access control in secure coding?",
    "choices": [
      "To restrict unauthorized access to sensitive resources",
      "To improve software performance",
      "To minimize code redundancy",
      "To reduce development time"
    ],
    "correctIndex": 0,
    "explanation": "Access control is a security measure that determines who can access what within a system. Its purpose is to enforce security policies and restrict unauthorized users from accessing sensitive data or functionalities, thereby protecting the system's integrity and confidentiality."
  },
  {
    "question": "In software engineering, ethics involves:",
    "choices": [
      "Considering societal impacts of software",
      "Maximizing profit at all costs",
      "Ensuring code is well-documented",
      "Ignoring legal obligations"
    ],
    "correctIndex": 0,
    "explanation": "Ethics in software engineering goes beyond technical and legal compliance. It requires engineers to consider the broader societal impacts of their work, including how their software might affect privacy, security, and human well-being."
  },
  {
    "question": "In the context of software security, which term refers to verifying the identity of users or systems?",
    "choices": [
      "Authentication",
      "Authorization",
      "Accounting",
      "Auditing"
    ],
    "correctIndex": 0,
    "explanation": "Authentication is the process of verifying a user's identity, typically through credentials like a username and password. Authorization, on the other hand, determines what an authenticated user is allowed to do."
  },
  {
    "question": "Ethical accountability ensures that engineers prioritize the ___________ impact of their software.",
    "choices": [
      "Social",
      "Financial",
      "Environmental",
      "Technical"
    ],
    "correctIndex": 0,
    "explanation": "Ethical accountability means that software engineers are responsible for the social and human impact of their work. They must consider the potential consequences of their software on society, including issues like bias, privacy, and accessibility."
  },
  {
    "question": "Software development compliance with intellectual property laws involves:",
    "choices": [
      "Ensuring all code is original or properly licensed",
      "Using free software exclusively",
      "Sharing software without restrictions",
      "Disregarding patents and copyrights aggregation"
    ],
    "correctIndex": 0,
    "explanation": "Compliance with intellectual property (IP) laws requires developers to respect the rights of others. This means that any code, libraries, or assets used in a project must either be original, or properly licensed from the creator to avoid legal issues related to copyright or patents."
  },
  {
    "question": "What is the main purpose of \"Code Reviews\" in secure development?",
    "choices": [
      "To identify and fix security vulnerabilities",
      "To document system requirements",
      "To improve software speed",
      "To test usability"
    ],
    "correctIndex": 0,
    "explanation": "Code reviews are a peer-based process where developers examine each other's code. In secure development, a primary goal of this process is to proactively identify and correct potential security vulnerabilities, coding errors, and logic flaws before the code is integrated and deployed."
  },
  {
    "question": "Which of the following security practices helps protect software by limiting access to only what is necessary for users to perform their tasks?",
    "choices": [
      "Principle of least privilege",
      "Multi-factor authentication",
      "Code designing",
      "Input validation"
    ],
    "correctIndex": 0,
    "explanation": "The Principle of Least Privilege is a security practice that mandates giving users or processes the minimum level of access rights and permissions needed to perform their job. This minimizes the potential damage if an account is compromised."
  },
  {
    "question": "Writing clean, structured code is unrelated to secure coding.",
    "choices": [
      "FALSE",
      "TRUE"
    ],
    "correctIndex": 0,
    "explanation": "FALSE. Writing clean, structured, and well-organized code is a core aspect of secure coding. It makes the codebase easier to read, understand, and review, which in turn makes it simpler to identify and prevent security vulnerabilities."
  },
  {
    "question": "Identify the fundamental ethical principle in software engineering.",
    "choices": [
      "Prioritizing user safety",
      "Writing minimal code",
      "Avoiding testing phases",
      "Ignoring user feedback"
    ],
    "correctIndex": 0,
    "explanation": "The fundamental ethical principle in software engineering is to prioritize the well-being and safety of the public. This includes protecting users from potential harm, such as data breaches, unsafe functionality, or misuse of personal information."
  },
  {
    "question": "Which of the following is a key goal of software security?",
    "choices": [
      "To protect software against vulnerabilities and threats",
      "To ensure high performance of the software",
      "To simplify user interfaces",
      "To improve software speed"
    ],
    "correctIndex": 0,
    "explanation": "The primary goal of software security is to protect the application, its data, and its users from a wide array of threats and vulnerabilities, thereby preserving the confidentiality, integrity, and availability of the system."
  },
  {
    "question": "A software development team is discussing application confidentiality. What does confidentiality refer to in software security?",
    "choices": [
      "Preventing unauthorized access to sensitive information",
      "The integrity of data",
      "Ensuring data is backed up",
      "The availability of software"
    ],
    "correctIndex": 0,
    "explanation": "Confidentiality, a core component of the CIA triad, means preventing unauthorized access to sensitive information. This is achieved through measures like encryption, access control, and secure storage."
  },
  {
    "question": "What is the consequence of non-compliance with industry regulations for software developers?",
    "choices": [
      "Legal penalties and loss of trust",
      "Increased revenue",
      "Enhanced customer loyalty",
      "Reduced development time"
    ],
    "correctIndex": 0,
    "explanation": "Non-compliance with regulations (e.g., GDPR, HIPAA) can lead to severe legal consequences, including fines and lawsuits. It can also cause a significant loss of public trust and reputational damage, which can harm business in the long run."
  },
  {
    "question": "Microservices communicate using ________ protocols.",
    "choices": [
      "REST",
      "SOAP",
      "FTP",
      "SMTP"
    ],
    "correctIndex": 0,
    "explanation": "Microservices often communicate using lightweight protocols. REST (Representational State Transfer) is a common architectural style for building APIs, making it a popular choice for inter-service communication due to its simplicity and statelessness."
  },
  {
    "question": "Which of the following AI tools assists with code completion?",
    "choices": [
      "GitHub Copilot",
      "Jenkins",
      "Docker",
      "Terraform"
    ],
    "correctIndex": 0,
    "explanation": "GitHub Copilot is a popular AI tool that assists developers by suggesting code snippets and completing code as they type, significantly speeding up the development process. The other options are DevOps tools for CI/CD, containerization, and infrastructure as code."
  },
  {
    "question": "What is a \"Runner\" in GitLab CI/CD?",
    "choices": [
      "An agent that executes pipeline jobs",
      "A testing framework",
      "A tool for code reviews",
      "A library for API integration"
    ],
    "correctIndex": 0,
    "explanation": "In GitLab CI/CD, a Runner is an agent that picks up jobs from the GitLab instance and executes them. This allows developers to run their build, test, and deployment jobs in an isolated environment."
  },
  {
    "question": "Which of the following is a version control system?",
    "choices": [
      "Git",
      "Jenkins",
      "Kubernetes",
      "Ansible"
    ],
    "correctIndex": 0,
    "explanation": "Git is a distributed version control system used to track changes in source code during software development. Jenkins, Kubernetes, and Ansible are all DevOps tools for continuous integration, container orchestration, and configuration management, respectively."
  },
  {
    "question": "What is the primary input for AI-based code completion tools?",
    "choices": [
      "Code syntax",
      "User behavior logs",
      "Hardware configurations",
      "Network diagrams"
    ],
    "correctIndex": 0,
    "explanation": "AI-based code completion tools analyze the code that has already been written (the code syntax and context) to predict and suggest the next lines of code."
  },
  {
    "question": "Neural networks are used in AI-driven software to simulate decision-making processes.",
    "choices": [
      "FALSE",
      "TRUE"
    ],
    "correctIndex": 0,
    "explanation": "FALSE. Neural networks, a subset of machine learning, are indeed used to simulate decision-making processes. Therefore, the statement is true, making the correct answer 'FALSE' for the provided question."
  },
  {
    "question": "In DevOps, \"Shift Left\" refers to:",
    "choices": [
      "Testing earlier in the software development lifecycle",
      "Automating all processes",
      "Using older development practices",
      "Reducing software costs"
    ],
    "correctIndex": 0,
    "explanation": "In DevOps, the principle of \"Shift Left\" means moving tasks, especially quality assurance and security testing, to an earlier stage in the software development lifecycle to find and fix issues more efficiently and at a lower cost."
  },
  {
    "question": "AI-driven development can enhance DevOps practices by:",
    "choices": [
      "Automating deployment strategies",
      "Slowing down CI/CD pipelines",
      "Increasing manual configuration",
      "Removing containerization"
    ],
    "correctIndex": 0,
    "explanation": "AI can enhance DevOps practices by automating complex tasks like deployment strategies, testing, and monitoring, thereby improving the efficiency and speed of CI/CD pipelines."
  },
  {
    "question": "Which Jenkins plugin is used to build Docker images?",
    "choices": [
      "Docker Pipeline Plugin",
      "Docker Build Plugin",
      "Container Builder Plugin",
      "Docker Hub Plugin"
    ],
    "correctIndex": 0,
    "explanation": "The 'Docker Pipeline' plugin in Jenkins is used to integrate Docker with Jenkins pipelines, allowing developers to build and manage Docker images as part of their CI/CD workflow."
  },
  {
    "question": "Which of the following is a challenge in AI-driven software development?",
    "choices": [
      "Lack of big data for training models",
      "Automating code testing",
      "Understanding unstructured data",
      "Reducing team size"
    ],
    "correctIndex": 0,
    "explanation": "While AI can help with these tasks, a major challenge in AI-driven development is the need for large, high-quality datasets to train models effectively. Without sufficient data, the AI's performance can be limited."
  },
  {
    "question": "Which Git command is used to view the commit history?",
    "choices": [
      "git log",
      "git status",
      "git diff",
      "git branch"
    ],
    "correctIndex": 0,
    "explanation": "The `git log` command displays a chronological list of all the commits in the repository. The other commands are used for checking the status of the working directory, showing changes between commits, and managing branches, respectively."
  },
  {
    "question": "AI-driven tools like SonarQube are primarily used for _____.",
    "choices": [
      "Code quality analysis",
      "Server management",
      "Database configuration",
      "Hardware diagnostics"
    ],
    "correctIndex": 0,
    "explanation": "SonarQube is a static analysis tool that uses AI and other techniques to perform automated reviews of code to detect bugs, vulnerabilities, and code smells, thus improving code quality."
  },
  {
    "question": "What does \"Infrastructure as Code\" (IaC) primarily help with?",
    "choices": [
      "Automating infrastructure provisioning",
      "Manual infrastructure provisioning",
      "Writing server-side applications",
      "Running manual scripts"
    ],
    "correctIndex": 0,
    "explanation": "IaC is a practice in DevOps that involves managing and provisioning computing infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools. Its primary goal is to automate the process."
  },
  {
    "question": "In cloud-native design, scaling by creating new instances is called ________ scaling.",
    "choices": [
      "Horizontal",
      "Vertical",
      "Static",
      "Dynamic"
    ],
    "correctIndex": 0,
    "explanation": "Horizontal scaling involves adding more machines to the resource pool, which is a key characteristic of cloud-native architecture. Vertical scaling, on the other hand, means increasing the capacity (e.g., CPU, RAM) of a single machine."
  },
  {
    "question": "What does AI-driven code generation primarily rely on?",
    "choices": [
      "Machine Learning algorithms",
      "Manual scripts",
      "Static libraries",
      "System logs"
    ],
    "correctIndex": 0,
    "explanation": "AI-driven code generation relies heavily on Machine Learning models, such as large language models, that are trained on vast datasets of code to generate new code based on prompts or context."
  },
  {
    "question": "Below are principles of DevOps, except:",
    "choices": [
      "Isolation",
      "Collaboration",
      "Automation",
      "Continuous Improvement"
    ],
    "correctIndex": 0,
    "explanation": "Collaboration, automation, and continuous improvement are all core principles of DevOps. Isolation, however, is a principle that DevOps seeks to break down, encouraging close cooperation between development and operations teams."
  },
  {
    "question": "In AI-driven tools, what is the purpose of a \"training dataset\"?",
    "choices": [
      "To teach models to identify patterns",
      "To validate software versions",
      "To create user interfaces",
      "To compile code faster"
    ],
    "correctIndex": 0,
    "explanation": "A training dataset is a collection of data used to train a machine learning model. The model learns from this data to recognize patterns and make predictions or classifications on new, unseen data."
  },
  {
    "question": "In Jenkins, what is a pipeline?",
    "choices": [
      "A series of automated steps for CI/CD",
      "A type of report",
      "A data backup tool",
      "A configuration file for Git"
    ],
    "correctIndex": 0,
    "explanation": "A Jenkins pipeline is a suite of plugins that supports implementing and integrating continuous delivery pipelines into Jenkins. It defines the entire software delivery process, from version control to deployment, as code."
  },
  {
    "question": "What does \"Immutable Infrastructure\" mean in DevOps?",
    "choices": [
      "Servers cannot be modified after deployment",
      "Infrastructure changes are permanent",
      "Backups are disabled",
      "Automation is avoided"
    ],
    "correctIndex": 0,
    "explanation": "Immutable infrastructure is a DevOps practice where servers are never modified after they are deployed. Any changes, such as patches or updates, require a new server to be created from a new image, which is then used to replace the old one."
  },
  {
    "question": "In blockchain, what does a \"block\" primarily contain?",
    "choices": [
      "Transaction data and a hash",
      "Only user credentials",
      "Source code and database schema",
      "Software artifacts"
    ],
    "correctIndex": 0,
    "explanation": "A block in a blockchain is a container for transaction data. Each block also contains a cryptographic hash of the previous block, creating a chain of interconnected blocks."
  },
  {
    "question": "In predictive software development, historical data is used to train ________ models.",
    "choices": [
      "Machine Learning",
      "Neural",
      "Software",
      "Hardware"
    ],
    "correctIndex": 0,
    "explanation": "Predictive software development relies on Machine Learning models. These models are trained on historical data, such as past development cycles, bug reports, or user feedback, to make predictions about future software behavior or development outcomes."
  },
  {
    "question": "Which AI technique is commonly used for anomaly detection in software logs?",
    "choices": [
      "Clustering",
      "Classification",
      "Reinforcement Learning",
      "Generative Adversarial Networks"
    ],
    "correctIndex": 0,
    "explanation": "Clustering is an unsupervised machine learning technique often used for anomaly detection. It groups similar log entries together, and any entries that do not fit into a cluster are flagged as potential anomalies or outliers."
  },
  {
    "question": "A ________ allows seamless service discovery in a microservices architecture.",
    "choices": [
      "Registry",
      "Load Balancer",
      "Proxy",
      "Controller"
    ],
    "correctIndex": 0,
    "explanation": "A service registry is a key component in a microservices architecture. It maintains a list of available microservices and their network locations, allowing other services to discover and communicate with them seamlessly."
  },
  {
    "question": "What does the \"git pull\" command do?",
    "choices": [
      "Fetch and merge changes from a remote repository",
      "Push changes to a remote repository",
      "Delete changes in the local repository",
      "Create a new branch"
    ],
    "correctIndex": 0,
    "explanation": "The `git pull` command is a combination of two other commands: `git fetch` (which downloads changes from the remote repository) and `git merge` (which merges those changes into the current branch)."
  },
  {
    "question": "Blockchain applications in software engineering enhance traceability and auditability.",
    "choices": [
      "True",
      "False"
    ],
    "correctIndex": 0,
    "explanation": "True. The immutable and distributed nature of blockchain technology makes it highly suitable for applications that require a secure and transparent record of events. This inherent quality enhances traceability and auditability by creating an unchangeable record of changes and transactions."
  },
  {
    "question": "Identify the characteristic that does not apply to cloud-native applications.",
    "choices": [
      "Monolithic",
      "Resilient",
      "Scalable",
      "Containerized"
    ],
    "correctIndex": 0,
    "explanation": "Cloud-native applications are typically designed using a microservices architecture, which is a departure from the monolithic approach. They are inherently designed to be resilient, scalable, and containerized to take full advantage of the cloud environment."
  },
  {
    "question": "A ________ is a disagreement between nodes on the state of the blockchain.",
    "choices": [
      "Fork",
      "Block",
      "Hash",
      "Node Conflict"
    ],
    "correctIndex": 0,
    "explanation": "A fork in a blockchain occurs when the chain splits into two different paths. This can happen when different nodes disagree on which block should be added next, resulting in a temporary or permanent divergence in the blockchain's history."
  },
  {
    "question": "Which of the following is a benefit of blockchain in software security?",
    "choices": [
      "Immutable data storage",
      "Centralized access control",
      "High latency transactions",
      "Reduced encryption standards"
    ],
    "correctIndex": 0,
    "explanation": "One of the key benefits of blockchain is its ability to provide immutable data storage. The cryptographic linking of blocks ensures that once data is added to the chain, it cannot be altered or deleted, which is a significant advantage for security and data integrity."
  },
  {
    "question": "Which of the following best defines cloud-native architecture?",
    "choices": [
      "Applications designed to leverage cloud computing benefits",
      "Applications built to run in on-premises servers",
      "Static software configurations",
      "Systems avoiding automation"
    ],
    "correctIndex": 0,
    "explanation": "Cloud-native architecture is a design approach for building applications that are specifically optimized to take full advantage of the benefits of cloud computing, such as scalability, elasticity, and resilience."
  },
  {
    "question": "In a DevOps pipeline, what does a \"build failure\" usually indicate?",
    "choices": [
      "Code did not compile successfully",
      "Missing test cases",
      "Lack of deployment servers",
      "Outdated version control"
    ],
    "correctIndex": 0,
    "explanation": "A build failure in a CI/CD pipeline typically indicates a problem during the compilation or packaging of the application's source code, often due to a syntax error or a dependency issue."
  },
  {
    "question": "AI models for software development can completely eliminate the need for manual testing.",
    "choices": [
      "FALSE",
      "TRUE"
    ],
    "correctIndex": 0,
    "explanation": "FALSE. While AI can significantly automate testing and find many bugs, human testers are still crucial for tasks like exploratory testing, user experience (UX) testing, and understanding nuanced user behavior that AI models cannot fully replicate."
  },
  {
    "question": "What is a major challenge of using microservices?",
    "choices": [
      "Complex inter-service communication",
      "Lack of modularity",
      "Static deployment",
      "Single-point failure"
    ],
    "correctIndex": 0,
    "explanation": "Microservices are composed of many small, independent services. A major challenge is managing the complex communication between these services, which can lead to issues with latency, fault tolerance, and data consistency."
  },
  {
    "question": "Which cloud-native design pattern ensures fault tolerance by limiting cascading failures?",
    "choices": [
      "Circuit Breaker",
      "Observer",
      "Singleton",
      "Proxy"
    ],
    "correctIndex": 0,
    "explanation": "The Circuit Breaker pattern is a design pattern used in cloud-native applications to prevent a failing service from causing cascading failures across other services. When a service fails, the circuit breaker opens, redirecting requests away from the failing service to a fallback mechanism until the service recovers."
  }
]


