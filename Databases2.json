[
  {
    "question": "Relations in Databases are usually visualized as...",
    "choices": [
      "Boxes",
      "Tables",
      "Hexagons",
      "Circles"
    ],
    "correctIndex": 1,
    "explanation": "In the relational model, data is organized into relations, which are intuitively visualized and implemented as **tables**. Each table consists of rows (tuples) and columns (attributes) representing the data and its relationships."
  },
  {
    "question": "What subsystems does a DBMS have?",
    "choices": [
      "A transaction manager, a query processor and a storage manager.",
      "A query processor and a storage manager",
      "A transaction manager and a query processor",
      "A schema operator and a dynamic ODBC interface"
    ],
    "correctIndex": 0,
    "explanation": "A standard Database Management System (DBMS) is composed of three core subsystems: the **query processor** (interprets and optimizes queries), the **transaction manager** (ensures data integrity and consistency), and the **storage manager** (handles data storage and retrieval from physical media)."
  },
  {
    "question": "What is the meaning of DDL?",
    "choices": [
      "Double Data Logic",
      "Delta Dynamic List",
      "Data Dynamic Language",
      "Data Definition Language"
    ],
    "correctIndex": 3,
    "explanation": "**DDL** stands for **Data Definition Language**. It is a subset of SQL used to define and modify the database structure or schema, including commands like `CREATE`, `ALTER`, and `DROP`."
  },
  {
    "question": "What is the difference between an instance and a schema?",
    "choices": [
    "The collection of information stored in the database at a particular moment is called a schema of the database. The overall design of the database is called the database instance.",
    "The collection of information stored in the database at any time is called an instance of the database. The overall design of the database is called the database schema.",
    "The relations and entities stored in the database that have a one-to-many cardinality are called an instance of the database. The overall collection of data in the database is called the database schema.",
    "The collection of particular moments in the database are called an instance of the database. The overall duration of the database is called the database schema.",
    "The collection of information stored in the database at a particular moment is called an instance of the database. The overall design of the database is called the database schema."
  ],
    "correctIndex": 4,
    "explanation": "A **schema** is the logical blueprint or overall design of the database which rarely changes. An **instance** is the specific snapshot of the collection of information stored in the database at a **particular moment** in time."
  },
  {
    "question": "What is a data query?",
    "choices": [
      "A piece of code that defines the rules for a DML compiler for further use.",
      "A piece of code that publishes the data on social media.",
      "A piece of code that adds data to the database.",
      "A piece of code that is understood by the DDL interpreter and returns data entries for further use."
    ],
    "correctIndex": 3,
    "explanation": "A **data query** is a request for information from a database. It is typically written in a query language (like SQL) and processed by the DBMS to retrieve specific data that matches the given criteria."
  },
  {
    "question": "You want to determine the cardinality of a database that matches persons with (official) ID cards. From a government perspective, what would be the ideal cardinality for a relation Person \u2013 ID card?",
    "choices": [
      "many to any",
      "many to many",
      "one to many",
      "one to one"
    ],
    "correctIndex": 3,
    "explanation": "Ideally, a single person should possess exactly one official ID card, and a single ID card should belong to exactly one person. This establishes a **one-to-one (1:1)** relationship, ensuring uniqueness and preventing identity fraud."
  },
  {
    "question": "Which of the following is NOT a type of access or manipulation for data queries?",
    "choices": [
      "Retrieval of Information stored in the database",
      "Insertion of new information into the database",
      "Interpretation of information stored in the database",
      "Deletion of information from the database"
    ],
    "correctIndex": 2,
    "explanation": "Standard data manipulation operations include **insertion, deletion, modification (update), and retrieval**. 'Interpretation' is a cognitive process performed by the user or application logic, not a direct database manipulation operation provided by the DBMS."
  },
  {
    "question": "What is a Cardinality?",
    "choices": [
      "The number of how many entities in a database are associated with a given entity.",
      "The number of entities in a database.",
      "The number of Cardinals that use databases.",
      "The total number of possible associations in a database."
    ],
    "correctIndex": 0,
    "explanation": "**Cardinality** in database modeling defines the numerical relationship between occurrences of one entity and another. It specifies whether the relationship is one-to-one, one-to-many, or many-to-many."
  },
  {
    "question": "Which elements does an object-oriented data model include?",
    "choices": [
      "abstraction, inheritance, and object action",
      "encapsulation, methods (functions), and object identity",
      "dynamic linked objects, library access (DLL\u2019s), and pointers",
      "big data capacity, recursive search, and normalized data"
    ],
    "correctIndex": 1,
    "explanation": "The object-oriented data model is characterized by core OOP concepts adapted for databases: **encapsulation** (bundling data and behavior), **methods** (functions defining object behavior), and **object identity** (unique distinction of each object)."
  },
  {
    "question": "Which of the following is NOT a well-known database system?",
    "choices": [
      "Microsoft SQL",
      "MySQL",
      "Oracle",
      "Adobe Application Manager"
    ],
    "correctIndex": 3,
    "explanation": "**Adobe Application Manager** is a utility for managing Adobe software installations and updates, not a database management system. Microsoft SQL Server, MySQL, Oracle, and PostgreSQL are all prominent DBMS examples."
  },
  {
    "question": "What is a structure described in a formal language supported by the database management system?",
    "choices": [
      "A database process",
      "A database transaction",
      "A database schema",
      "A database query"
    ],
    "correctIndex": 2,
    "explanation": "A **database schema** is the formal description of the database structure, defined using a Data Definition Language (DDL). It outlines the tables, fields, relationships, views, indexes, and other elements that make up the database."
  },
  {
    "question": "What kind of symbol is used in a diagram for a relationship set.",
    "choices": [
      "A circle",
      "A line",
      "An oval",
      "A diamond"
    ],
    "correctIndex": 3,
    "explanation": "In Entity-Relationship (ER) diagrams, a **diamond** symbol is the standard notation used to represent a **relationship set**, which depicts the association between entity sets (rectangles)."
  },
  {
    "question": "What are the two main architectures for DBMS\u2019s?",
    "choices": [
      "The Last-in-first-out (LIFO) architecture and the First-in-first-out (FIFO) architecture",
      "The Fast Output and the Ultra Fast Output (UFO) architecture",
      "The two-tier and the three-tier architecture",
      "The FBI and the CIA security architecture"
    ],
    "correctIndex": 2,
    "explanation": "The two predominant architectures for DBMS deployment are **two-tier** (client-server, where the application communicates directly with the database) and **three-tier** (client-application server-database server, adding an intermediate logic layer)."
  },
  {
    "question": "What does the acronym DML stand for?",
    "choices": [
      "Data Manipulation Language",
      "Data Mining Language",
      "Data Mining List",
      "Dynamic Meta Language"
    ],
    "correctIndex": 0,
    "explanation": "**DML** stands for **Data Manipulation Language**. It is a subset of SQL commands used to manage data within the database, including operations like `SELECT`, `INSERT`, `UPDATE`, and `DELETE`."
  },
  {
    "question": "What is the name of a commonly used database model?",
    "choices": [
      "The Equity Relationship Model",
      "The Eternity Relationship Model",
      "The Entity Relationship Model",
      "The External Relationship Model"
    ],
    "correctIndex": 2,
    "explanation": "The **Entity-Relationship (ER) Model** is a widely used conceptual data model for designing databases. It represents data as entities, attributes, and relationships, providing a high-level view of the data structure."
  },
  {
    "question": "Which of the following are the levels of data abstraction?",
    "choices": [
      "Physical level, protection level and access level",
      "Logical level, level of perception and action level",
      "Physical level, logical level and application level",
      "Physical level, logical level and view level"
    ],
    "correctIndex": 3,
    "explanation": "The three standard levels of data abstraction in a DBMS are the **Physical level** (how data is stored), the **Logical level** (what data is stored and relationships), and the **View level** (what part of the data is visible to users)."
  },
  {
    "question": "What does DBMS stand for?",
    "choices": [
      "Databases by Microsoft",
      "Database Management-System",
      "Data Bound Managerial Safety",
      "Data Big Mining Software"
    ],
    "correctIndex": 1,
    "explanation": "**DBMS** stands for **Database Management System**. It is the system software responsible for creating, managing, storing, retrieving, and updating data in a database."
  },
  {
    "question": "What would a basic SQL query look like?",
    "choices": [
      "SELECT * FROM DATA",
      "SELECT * OF DATA",
      "CHOOSE * FROM DATA",
      "PRINT * OF DATA"
    ],
    "correctIndex": 0,
    "explanation": "A fundamental SQL query for retrieving all data from a table named 'DATA' follows the syntax: **`SELECT * FROM DATA`**. `SELECT` specifies retrieval, `*` selects all columns, and `FROM` specifies the source table."
  },
  {
    "question": "Which of the following is NOT a data model?",
    "choices": [
      "Rational Model",
      "Relational Model",
      "Entity-Relationship Model",
      "Object-based Model"
    ],
    "correctIndex": 0,
    "explanation": "The **'Rational Model'** is not a standard term in database theory. The correct term is the **Relational Model**. Other valid data models include the Entity-Relationship Model, Object-based Model, and Semistructured Model."
  },
  {
    "question": "What term describes the effect on a long transaction if a sequence of conflicting short transactions causes repeated restarting of the long transaction?",
    "choices": [
      "Oblivion",
      "Obliteration",
      "Starvation",
      "Failure",
      "Deadlock"
    ],
    "correctIndex": 2,
    "explanation": "**Starvation** occurs when a transaction cannot proceed for an indefinite period because other transactions continuously block it or cause it to restart. This typically happens to long-running transactions that repeatedly conflict with a stream of shorter, faster transactions."
  },
  {
    "question": "When is a transaction schedule legal?",
    "choices": [
      "If it follows the law as stipulated in United Nations bill on data integrity, section 283.5B.",
      "If it follows the rules of the locking protocol that is in place.",
      "If it is serializable and recoverable.",
      "If it is reversible.",
      "If it is irreversible."
    ],
    "correctIndex": 1,
    "explanation": "A transaction schedule is considered **legal** if it strictly adheres to the rules defined by the database's concurrency control protocols, such as a locking protocol. These rules ensure that the execution order of operations maintains data consistency and integrity."
  },
  {
    "question": "What do you call a system’s main memory or system cache?",
    "choices": [
      "Volatile storage",
      "Non-volatile storage",
      "Stable storage",
      "Shadow storage",
      "Phantom storage"
    ],
    "correctIndex": 0,
    "explanation": "**Volatile storage** refers to memory that requires power to maintain the stored information, such as RAM (main memory) and cache. Data in volatile storage is lost immediately if the system crashes or loses power, unlike non-volatile storage like hard disks."
  },
  {
    "question": "What, in a nutshell, does Thomas’ write rule do?",
    "choices": [
      "It helps generate serializable schedules.",
      "It helps generate conflict free schedules.",
      "It helps generate schedules that can be aborted without error.",
      "It helps generate cascadeless schedules.",
      "It helps generate schedules with no read operations."
    ],
    "correctIndex": 0,
    "explanation": " **Thomas' write rule** is a timestamp-based concurrency control rule that allows certain outdated write operations to be ignored rather than aborted. By doing so, it permits a broader set of schedules to be considered view **serializable**, improving system concurrency."
  },
  {
    "question": "When are two Schedules “conflict equivalent”?",
    "choices": [
      "If they cause the same type of conflicts.",
      "If they do not conflict each other.",
      "If they are in conflict with each other.",
      "If they can be transformed from one into the other by reversing the order of instructions.",
      "If they can be transformed from one into the other by a series of swaps and non-conflicting instructions."
    ],
    "correctIndex": 4,
    "explanation": "Two schedules are **conflict equivalent** if they involve the same set of transactions and the order of any two conflicting operations is the same in both. Practically, this means one schedule can be transformed into the other by swapping adjacent non-conflicting operations."
  },
  {
    "question": "What is the difference between shared-mode and exclusive lock?",
    "choices": [
      "When there is a shared-mode lock, the transaction cannot write and read the data item, where in an exclusive lock, the transaction can both write and read the data item.",
      "When there is a shared-mode lock, the transaction cannot read the data item, where in an exclusive lock, the transaction can write the data item.",
      "When there is a shared-mode lock, the transaction can write and read the data item, where in an exclusive lock, the transaction can write but not read the data item.",
      "When there is a shared-mode lock, the transaction can read but not write the data item, where in an exclusive lock, the transaction can both write and read the data item.",
      "When there is a shared-mode lock, the transaction can write and read the data item, where in an exclusive lock, the transaction can also write and read the data item."
    ],
    "correctIndex": 3,
    "explanation": "A **shared-mode lock (S)** allows a transaction to read a data item but not modify it, permitting other transactions to also hold shared locks. An **exclusive lock (X)** allows a transaction to both read and write the data item, blocking all other transactions from accessing it."
  },
  {
    "question": " A transaction can be…",
    "choices": [
      "Hurt",
      "Killed",
      "Buried",
      "Robbed",
      "Blackmailed"
    ],
    "correctIndex": 1,
    "explanation": "In the context of deadlock prevention schemes like 'Wait-Die' or 'Wound-Wait', a transaction can be **killed** (aborted and rolled back) by the system to resolve a conflict or deadlock scenario."
  },
  {
    "question": "When does a deadlock happen?",
    "choices": [
      "If every transaction is waiting for another transaction to finish.",
      "If a schedule of transactions is rolling itself back without result.",
      "If there is a transaction in a schedule that has a logical error.",
      "If a transaction has been corrupted by system failure.",
      "If the database locks down completely and all data is lost."
    ],
    "correctIndex": 0,
    "explanation": "A **deadlock** occurs when a set of transactions are blocked because each transaction is holding a resource that another transaction in the set needs. This creates a cyclic dependency where every transaction is waiting for another to finish, so none can proceed."
  },
  {
    "question": "What do you call a transaction that is responsible for a deadlock and has been chosen to be rolled back?",
    "choices": [
      "A witness",
      "A hostage",
      "A criminal",
      "A victim",
      "A felon"
    ],
    "correctIndex": 3,
    "explanation": "When a deadlock detection algorithm identifies a deadlock cycle, it must select one transaction to abort to break the cycle. This selected transaction is referred to as the **victim**. The system rolls it back to release its locks."
  },
  {
    "question": "What properties should database transactions ideally have?",
    "choices": [
      "Atomicity, Consistency, Isolation, Durability (ACID)",
      "Automation, Connectivity, Invulnerability, Distribution (ACID)",
      "Aspectualization, Centricity, Impact, Dependencies (ACID)",
      "Aggregation, Coordination, Indestructability, Doubling (ACID)",
      "Attributes, Code, Indices, Data (ACID)"
    ],
    "correctIndex": 0,
    "explanation": "The ideal properties of database transactions are known by the acronym **ACID**: **Atomicity** (all or nothing), **Consistency** (data remains valid), **Isolation** (concurrent transactions don't interfere), and **Durability** (committed data is saved permanently)."
  },
  {
    "question": "When can an aborted transaction be restarted?",
    "choices": [
      "When the transaction itself is correct but was aborted by a software or hardware error.",
      "When the transaction was aborted due to an internal error in the transaction logic.",
      "When the transaction failed because of a division by zero.",
      "When the transaction would have caused data to be corrupted.",
      "When the transaction made no sense."
    ],
    "correctIndex": 0,
    "explanation": "A transaction can be safely restarted if it was aborted due to external factors like a **software crash, hardware failure, or concurrency control mechanism** (like deadlock resolution). If the transaction logic itself caused the error (e.g., internal logic error), restarting it would just cause the same error again."
  },
  {
    "question": "What happens if a validation of a transaction fails?",
    "choices": [
      "The transaction gets rolled back.",
      "The transaction fails and enters into a deadlock.",
      "The transaction gets postponed.",
      "The transaction gets earmarked as possibly problematic but completes anyway.",
      "The database gets corrupted and all data is lost."
    ],
    "correctIndex": 0,
    "explanation": "In optimistic concurrency control, the validation phase checks if the transaction's changes conflict with others. If this validation fails, the transaction cannot be allowed to commit, so it is **rolled back** (aborted) and typically restarted."
  },
  {
    "question": "In Databases, collections of operations that form a single logical unit of work are called...",
    "choices": [
      "Modifications",
      "Queries",
      "Transactions",
      "Transfers",
      "Bulk operations"
    ],
    "correctIndex": 2,
    "explanation": "A **transaction** is the fundamental unit of execution in a database management system. It represents a sequence of one or more operations (reads and writes) that are treated as a single, atomic logical unit of work."
  },
  {
    "question": "What happens in the validation phase of a transaction?",
    "choices": [
      "It tests for conflicts of any kind.",
      "It tests for data corruption and aborts the transaction if it finds a problem.",
      "It creates an additional transaction to check if the transaction can be rolled back.",
      "It tests whether the transaction causes a violation of serializability.",
      "It deletes the data modified by the transaction and overwrites them with default values."
    ],
    "correctIndex": 3,
    "explanation": "The validation phase is a crucial step in optimistic concurrency control protocols. During this phase, the system checks if the transaction's execution conflicts with any other concurrent transactions in a way that would violate **serializability**, ensuring data consistency."
  },
  {
    "question": "How can you test a schedule for conflict serializability?",
    "choices": [
      "By counting the number of transactions. If the number is odd, the schedule is conflict serializable.",
      "By counting the number of transactions. If the number is even, the schedule is conflict serializable.",
      "By drawing a precedence graph. A schedule is conflict serializable if its precedence graph has no cycle.",
      "By running the schedule. If there is no error, the schedule is conflict serializable.",
      "By checking if there are the same amount of write as read operations."
    ],
    "correctIndex": 2,
    "explanation": "The standard method to test for conflict serializability is to construct a **precedence graph** (or serialization graph). Nodes represent transactions, and directed edges represent conflicting operations. If the resulting graph contains **no cycles**, the schedule is conflict serializable."
  },
  {
    "question": "What is a transaction identifier?",
    "choices": [
      "It is the unique identifier of the transaction that performed the read operation.",
      "It is the unique identifier of the transaction that performed the write operation.",
      "It is the unique identifier of the transaction that performed the delete operation.",
      "It is the unique identifier of the transaction that performed the commit operation.",
      "It is the unique identifier of the transaction that performed the stop operation."
    ],
    "correctIndex": 1,
    "explanation": "In the context of log records for database recovery, a transaction identifier typically refers to the unique ID associated with the transaction that performed a specific action, such as a **write operation** on a data item."
  },
  {
    "question": "What is needed to achieve Serializability?",
    "choices": [
      "A set of operations that run concurrently",
      "A concurrency-control scheme",
      "A database schema using recovery management",
      "A transaction schedule that avoids blind write operations",
      "A data lock"
    ],
    "correctIndex": 1,
    "explanation": "To ensure that concurrent transactions produce results equivalent to some serial execution (serializability), a database system must implement a **concurrency-control scheme** (or protocol), such as two-phase locking or timestamp ordering."
  },
  {
    "question": "What is an advantage of concurrency?",
    "choices": [
      "The CPU generates less heat.",
      "The security of the database is increased.",
      "The waiting time is reduced.",
      "The failure rate of transactions is reduced.",
      "The throughput is reduced."
    ],
    "correctIndex": 2,
    "explanation": "Concurrency allows multiple transactions to make progress simultaneously. This significantly **reduces the average waiting time** for users and transactions, as short transactions don't have to wait for long ones to complete fully, and it improves overall system throughput."
  },
  {
    "question": "Which of the following is NOT a transaction state?",
    "choices": [
      "Committed",
      "Aborted",
      "Failed",
      "Attempted",
      "Active"
    ],
    "correctIndex": 3,
    "explanation": "The standard states of a database transaction are **Active, Partially Committed, Failed, Aborted, and Committed**. **Attempted** is not a formally defined state in the standard transaction state model."
  },
  {
    "question": "What is a cascadeless schedule?",
    "choices": [
      "A schedule where the whole set of instructions takes the shape of only one single cascade.",
      "A schedule where cascading rollbacks cannot occur.",
      "A schedule where cascades are avoided by allowing rollbacks.",
      "A schedule where a cascade is rolled forth and then directly rolled back.",
      "Cascadeless schedules cannot exist, because every schedule has a cascade."
    ],
    "correctIndex": 1,
    "explanation": "A **cascadeless schedule** ensures that if a transaction $T_j$ reads a data item modified by $T_i$, then $T_i$ must have committed before the read occurs. This prevents **cascading rollbacks**, where the abort of one transaction forces the abort of dependent transactions."
  }

]
